{"version":3,"sources":["../../src/emoji/picker.js"],"names":["ROW_RENDER_BUFFER_COUNT","RECENT_EMOJIS_STORAGE_KEY","ROW_HEIGHT_RAW","EMOJIS_PER_ROW","ROW_TYPE","EMOJI","HEADER","SELECTORS","CATEGORY_SELECTOR","EMOJIS_CONTAINER","EMOJI_PREVIEW","EMOJI_SHORT_NAME","ROW_CONTAINER","SEARCH_INPUT","SEARCH_RESULTS_CONTAINER","createRowDataForCategory","categoryName","emojis","totalRowCount","rowData","push","index","length","type","data","i","rowEmojis","slice","addIndexesToRowData","map","getCategoryScrollPositionsFromRowData","reduce","carry","row","createHeaderRow","rowIndex","name","context","text","html","temp","document","createElement","innerHTML","firstChild","createEmojiRow","emojiData","charCodes","unified","split","code","emojiText","String","fromCodePoint","apply","shortnames","join","spacer","spacers","Array","fill","isEmojiElement","element","getAttribute","findCategorySelectorFromElement","parentElement","getCategorySelectorByCategoryName","root","querySelector","setCategorySelectorActive","allCategorySelectors","querySelectorAll","forEach","selector","classList","remove","add","getCategoryByScrollPosition","position","categoryScrollPositions","positions","categoryPosition","sort","a","b","candidate","previousPosition","currentPosition","nextPosition","getRecentEmojis","storedData","LocalStorage","get","JSON","parse","saveRecentEmoji","recentEmojis","set","stringify","addRecentEmoji","recentEmojiRowCount","newEmoji","newRecentEmojis","filter","emoji","newRecentEmojiRowData","concat","getRowsToRender","scrollPosition","visibleRowCount","minVisibleRow","Math","floor","start","rows","createRowElement","style","left","right","top","doRowsMatch","renderRows","rowContainer","currentRows","nextRows","toAdd","nextRow","some","currentRow","toKeep","toRemove","toRemoveElements","Promise","all","nextRowIndex","nextRowData","nextRowNode","insertBefore","splice","append","removeChild","generateRenderRowsAtPositionFunction","rowCount","isRendering","renderNextRows","nextRowsToRender","rowLimit","height","showSearchResults","emojiContainer","searchResultsContainer","clearSearch","searchInput","value","getHandleMouseEnter","emojiPreview","emojiShortName","e","target","textContent","getHandleMouseLeave","getHandleClick","selectCallback","renderAtPosition","newRowData","newCategoryScrollPositions","replace","currentScrollTop","scrollTop","isRecentEmojiRowVisible","categorySelector","selectedCategory","getHandleScroll","currentVisibleRowScrollPosition","initialCategoryScrollPositions","currentCategoryElement","previousCategoryPosition","nextCategoryPosition","newScrollPosition","upperScrollBound","lowerScrollBound","updateActiveCategory","requestAnimationFrame","getHandleSearch","renderSearchResultsAtPosition","searchTerm","matchingEmojis","Object","keys","EmojiData","byShortName","shortName","includes","searchResultsString","registerEventListeners","clickHandler","scrollHandler","searchHandler","addEventListener","allData","byCategory","category","categoryDisplayName","title","categoryRowData"],"mappings":"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","sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * Emoji picker.\n *\n * @copyright  2019 Ryan Wyllie <ryan@moodle.com>\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\nimport LocalStorage from 'core/localstorage';\nimport * as EmojiData from 'core_message/emoji/data';\nimport {throttle, debounce} from 'core/utils';\nimport {get_string} from 'core/str';\nimport {render as renderTemplate} from 'core/templates';\n\nconst VISIBLE_ROW_COUNT = 10;\nconst ROW_RENDER_BUFFER_COUNT = 5;\nconst RECENT_EMOJIS_STORAGE_KEY = 'moodle-recent-emojis';\nconst ROW_HEIGHT_RAW = 40;\nconst EMOJIS_PER_ROW = 7;\nconst MAX_RECENT_COUNT = EMOJIS_PER_ROW * 3;\nconst ROW_TYPE = {\n    EMOJI: 0,\n    HEADER: 1\n};\nconst SELECTORS = {\n    CATEGORY_SELECTOR: '[data-action=\"show-category\"]',\n    EMOJIS_CONTAINER: '[data-region=\"emojis-container\"]',\n    EMOJI_PREVIEW: '[data-region=\"emoji-preview\"]',\n    EMOJI_SHORT_NAME: '[data-region=\"emoji-short-name\"]',\n    ROW_CONTAINER: '[data-region=\"row-container\"]',\n    SEARCH_INPUT: '[data-region=\"search-input\"]',\n    SEARCH_RESULTS_CONTAINER: '[data-region=\"search-results-container\"]'\n};\n\n/**\n * Create the row data for a category.\n *\n * @param {String} categoryName The category display name\n * @param {Array} emojis The emoji data\n * @param {Number} totalRowCount The total number of rows generated so far\n * @return {Array}\n */\nconst createRowDataForCategory = (categoryName, emojis, totalRowCount) => {\n    const rowData = [];\n    rowData.push({\n        index: totalRowCount + rowData.length,\n        type: ROW_TYPE.HEADER,\n        data: categoryName\n    });\n\n    for (let i = 0; i < emojis.length; i += EMOJIS_PER_ROW) {\n        const rowEmojis = emojis.slice(i, i + EMOJIS_PER_ROW);\n        rowData.push({\n            index: totalRowCount + rowData.length,\n            type: ROW_TYPE.EMOJI,\n            data: rowEmojis\n        });\n    }\n\n    return rowData;\n};\n\n/**\n * Add each row's index to it's value in the row data.\n *\n * @param {Array} rowData List of emoji row data\n * @return {Array}\n */\nconst addIndexesToRowData = (rowData) => {\n    return rowData.map((data, index) => {\n        return {...data, index};\n    });\n};\n\n/**\n * Calculate the scroll position for the beginning of each category from\n * the row data.\n *\n * @param {Array} rowData List of emoji row data\n * @return {Object}\n */\nconst getCategoryScrollPositionsFromRowData = (rowData) => {\n    return rowData.reduce((carry, row, index) => {\n        if (row.type === ROW_TYPE.HEADER) {\n            carry[row.data] = index * ROW_HEIGHT_RAW;\n        }\n        return carry;\n    }, {});\n};\n\n/**\n * Create a header row element for the category name.\n *\n * @param {Number} rowIndex Index of the row in the row data\n * @param {String} name The category display name\n * @return {Element}\n */\nconst createHeaderRow = async (rowIndex, name) => {\n    const context = {\n        index: rowIndex,\n        text: name\n    };\n    const html = await renderTemplate('core_message/emoji/header_row', context);\n    const temp = document.createElement('div');\n    temp.innerHTML = html;\n    return temp.firstChild;\n};\n\n/**\n * Create an emoji row element.\n *\n * @param {Number} rowIndex Index of the row in the row data\n * @param {Array} emojis The list of emoji data for the row\n * @return {Element}\n */\nconst createEmojiRow = async (rowIndex, emojis) => {\n    const context = {\n        index: rowIndex,\n        emojis: emojis.map(emojiData => {\n            const charCodes = emojiData.unified.split('-').map(code => `0x${code}`);\n            const emojiText = String.fromCodePoint.apply(null, charCodes);\n            return {\n                shortnames: `:${emojiData.shortnames.join(': :')}:`,\n                unified: emojiData.unified,\n                text: emojiText,\n                spacer: false\n            };\n        }),\n        spacers: Array(EMOJIS_PER_ROW - emojis.length).fill(true)\n    };\n    const html = await renderTemplate('core_message/emoji/emoji_row', context);\n    const temp = document.createElement('div');\n    temp.innerHTML = html;\n    return temp.firstChild;\n};\n\n/**\n * Check if the element is an emoji element.\n *\n * @param {Element} element Element to check\n * @return {Bool}\n */\nconst isEmojiElement = element => element.getAttribute('data-short-names') !== null;\n\n/**\n * Search from an element and up through it's ancestors to fine the category\n * selector element and return it.\n *\n * @param {Element} element Element to begin searching from\n * @return {Element|null}\n */\nconst findCategorySelectorFromElement = element => {\n    if (!element) {\n        return null;\n    }\n\n    if (element.getAttribute('data-action') === 'show-category') {\n        return element;\n    } else {\n        return findCategorySelectorFromElement(element.parentElement);\n    }\n};\n\nconst getCategorySelectorByCategoryName = (root, name) => {\n    return root.querySelector(`[data-category=\"${name}\"]`);\n};\n\n/**\n * Sets the given category selector element as active.\n *\n * @param {Element} root The root picker element\n * @param {Element} element The category selector element to make active\n */\nconst setCategorySelectorActive = (root, element) => {\n    const allCategorySelectors = root.querySelectorAll(SELECTORS.CATEGORY_SELECTOR);\n    allCategorySelectors.forEach(selector => {\n        selector.classList.remove('selected');\n    });\n\n    element.classList.add('selected');\n};\n\n/**\n * Get the category selector element and the scroll positions for the previous and\n * next categories for the given scroll position.\n *\n * @param {Element} root The picker root element\n * @param {Number} position The position to get the category for\n * @param {Object} categoryScrollPositions Set of scroll positions for all categories\n * @return {Array}\n */\nconst getCategoryByScrollPosition = (root, position, categoryScrollPositions) => {\n    let positions = [];\n\n    // Get all of the category positions.\n    for (const categoryName in categoryScrollPositions) {\n        const categoryPosition = categoryScrollPositions[categoryName];\n        positions.push([categoryPosition, categoryName]);\n    }\n\n    // Sort the positions in ascending order.\n    positions.sort(([a], [b]) => {\n        if (a < b) {\n            return -1;\n        } else if (a > b) {\n            return 1;\n        } else {\n            return 0;\n        }\n    });\n\n    // Get the current category name as well as the previous and next category\n    // positions from the sorted list of positions.\n    const {categoryName, previousPosition, nextPosition} = positions.reduce(\n        (carry, candidate) => {\n            const [categoryPosition, categoryName] = candidate;\n\n            if (categoryPosition <= position) {\n                carry.categoryName = categoryName;\n                carry.previousPosition = carry.currentPosition;\n                carry.currentPosition = position;\n            } else if (carry.nextPosition === null) {\n                carry.nextPosition = categoryPosition;\n            }\n\n            return carry;\n        },\n        {\n            categoryName: null,\n            currentPosition: null,\n            previousPosition: null,\n            nextPosition: null\n        }\n    );\n\n    return [getCategorySelectorByCategoryName(root, categoryName), previousPosition, nextPosition];\n};\n\n/**\n * Get the list of recent emojis data from local storage.\n *\n * @return {Array}\n */\nconst getRecentEmojis = () => {\n    const storedData = LocalStorage.get(RECENT_EMOJIS_STORAGE_KEY);\n    return storedData ? JSON.parse(storedData) : [];\n};\n\n/**\n * Save the list of recent emojis in local storage.\n *\n * @param {Array} recentEmojis List of emoji data to save\n */\nconst saveRecentEmoji = (recentEmojis) => {\n    LocalStorage.set(RECENT_EMOJIS_STORAGE_KEY, JSON.stringify(recentEmojis));\n};\n\n/**\n * Add an emoji data to the set of recent emojis. This function will update the row\n * data to ensure that the recent emoji rows are correct and all of the rows are\n * re-indexed.\n *\n * The new set of recent emojis are saved in local storage and the full set of updated\n * row data and new emoji row count are returned.\n *\n * @param {Array} rowData The emoji rows data\n * @param {Number} recentEmojiRowCount Count of the recent emoji rows\n * @param {Object} newEmoji The emoji data for the emoji to add to the recent emoji list\n * @return {Array}\n */\nconst addRecentEmoji = (rowData, recentEmojiRowCount, newEmoji) => {\n    // The first set of rows is always the recent emojis.\n    const categoryName = rowData[0].data;\n    const recentEmojis = getRecentEmojis();\n    // Add the new emoji to the start of the list of recent emojis.\n    let newRecentEmojis = [newEmoji, ...recentEmojis.filter(emoji => emoji.unified != newEmoji.unified)];\n    // Limit the number of recent emojis.\n    newRecentEmojis = newRecentEmojis.slice(0, MAX_RECENT_COUNT);\n    const newRecentEmojiRowData = createRowDataForCategory(categoryName, newRecentEmojis);\n\n    // Save the new list in local storage.\n    saveRecentEmoji(newRecentEmojis);\n\n    return [\n        // Return the new rowData and re-index it to make sure it's all correct.\n        addIndexesToRowData(newRecentEmojiRowData.concat(rowData.slice(recentEmojiRowCount))),\n        newRecentEmojiRowData.length\n    ];\n};\n\n/**\n * Calculate which rows should be visible based on the given scroll position. Adds a\n * buffer to amount to either side of the total number of requested rows so that\n * scrolling the emoji rows container is smooth.\n *\n * @param {Number} scrollPosition Scroll position within the emoji container\n * @param {Number} visibleRowCount How many rows should be visible\n * @param {Array} rowData The emoji rows data\n * @return {Array}\n */\nconst getRowsToRender = (scrollPosition, visibleRowCount, rowData) => {\n    const minVisibleRow = scrollPosition > ROW_HEIGHT_RAW ? Math.floor(scrollPosition / ROW_HEIGHT_RAW) : 0;\n    const start = minVisibleRow >= ROW_RENDER_BUFFER_COUNT ? minVisibleRow - ROW_RENDER_BUFFER_COUNT : minVisibleRow;\n    const end = minVisibleRow + visibleRowCount + ROW_RENDER_BUFFER_COUNT;\n    const rows = rowData.slice(start, end);\n    return rows;\n};\n\n/**\n * Create a row element from the row data.\n *\n * @param {Object} rowData The emoji row data\n * @return {Element}\n */\nconst createRowElement = async (rowData) => {\n    let row = null;\n    if (rowData.type === ROW_TYPE.HEADER) {\n        row = await createHeaderRow(rowData.index, rowData.data);\n    } else {\n        row = await createEmojiRow(rowData.index, rowData.data);\n    }\n\n    row.style.position = 'absolute';\n    row.style.left = 0;\n    row.style.right = 0;\n    row.style.top = `${rowData.index * ROW_HEIGHT_RAW}px`;\n\n    return row;\n};\n\n/**\n * Check if the given rows match.\n *\n * @param {Object} a The first row\n * @param {Object} b The second row\n * @return {Bool}\n */\nconst doRowsMatch = (a, b) => {\n    if (a.index !== b.index) {\n        return false;\n    }\n\n    if (a.type !== b.type) {\n        return false;\n    }\n\n    if (typeof a.data != typeof b.data) {\n        return false;\n    }\n\n    if (a.type === ROW_TYPE.HEADER) {\n        return a.data === b.data;\n    } else {\n        if (a.data.length !== b.data.length) {\n            return false;\n        }\n\n        for (let i = 0; i < a.data.length; i++) {\n            if (a.data[i].unified != b.data[i].unified) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n};\n\n/**\n * Update the visible rows. Deletes any row elements that should no longer\n * be visible and creates the newly visible row elements. Any rows that haven't\n * changed visibility will be left untouched.\n *\n * @param {Element} rowContainer The container element for the emoji rows\n * @param {Array} currentRows List of row data that matches the currently visible rows\n * @param {Array} nextRows List of row data containing the new list of rows to be made visible\n */\nconst renderRows = async (rowContainer, currentRows, nextRows) => {\n    // We need to add any rows that are in nextRows but not in currentRows.\n    const toAdd = nextRows.filter(nextRow => !currentRows.some(currentRow => doRowsMatch(currentRow, nextRow)));\n    // Remember which rows will still be visible so that we can insert our element in the correct place in the DOM.\n    let toKeep = currentRows.filter(currentRow => nextRows.some(nextRow => doRowsMatch(currentRow, nextRow)));\n    // We need to remove any rows that are in currentRows but not in nextRows.\n    const toRemove = currentRows.filter(currentRow => !nextRows.some(nextRow => doRowsMatch(currentRow, nextRow)));\n    const toRemoveElements = toRemove.map(rowData => rowContainer.querySelectorAll(`[data-row=\"${rowData.index}\"]`));\n\n    // Render all of the templates first.\n    const rows = await Promise.all(toAdd.map(rowData => createRowElement(rowData)));\n\n    rows.forEach((row, index) => {\n        const rowData = toAdd[index];\n        let nextRowIndex = null;\n\n        for (let i = 0; i < toKeep.length; i++) {\n            const candidate = toKeep[i];\n            if (candidate.index > rowData.index) {\n                nextRowIndex = i;\n                break;\n            }\n        }\n\n        // Make sure the elements get added to the DOM in the correct order (ascending by row data index)\n        // so that they appear naturally in the tab order.\n        if (nextRowIndex !== null) {\n            const nextRowData = toKeep[nextRowIndex];\n            const nextRowNode = rowContainer.querySelector(`[data-row=\"${nextRowData.index}\"]`);\n\n            rowContainer.insertBefore(row, nextRowNode);\n            toKeep.splice(nextRowIndex, 0, toKeep);\n        } else {\n            toKeep.push(rowData);\n            rowContainer.append(row);\n        }\n    });\n\n    toRemoveElements.forEach(rows => rows.forEach(row => rowContainer.removeChild(row)));\n};\n\n/**\n * Build a function to render the visible emoji rows for a given scroll\n * position.\n *\n * @param {Element} rowContainer The container element for the emoji rows\n * @return {Function}\n */\nconst generateRenderRowsAtPositionFunction = (rowContainer) => {\n    let currentRows = [];\n    let nextRows = [];\n    let rowCount = 0;\n    let isRendering = false;\n    const renderNextRows = async () => {\n        if (!nextRows.length) {\n            return;\n        }\n\n        if (isRendering) {\n            return;\n        }\n\n        isRendering = true;\n        const nextRowsToRender = nextRows.slice();\n        nextRows = [];\n\n        await renderRows(rowContainer, currentRows, nextRowsToRender);\n        currentRows = nextRowsToRender;\n        isRendering = false;\n        renderNextRows();\n    };\n\n    return (scrollPosition, rowData, rowLimit = VISIBLE_ROW_COUNT) => {\n        nextRows = getRowsToRender(scrollPosition, rowLimit, rowData);\n        renderNextRows();\n\n        if (rowCount !== rowData.length) {\n            // Adjust the height of the container to match the number of rows.\n            rowContainer.style.height = `${rowData.length * ROW_HEIGHT_RAW}px`;\n        }\n\n        rowCount = rowData.length;\n    };\n};\n\n/**\n * Show the search results container and hide the emoji container.\n *\n * @param {Element} emojiContainer The emojis container\n * @param {Element} searchResultsContainer The search results container\n */\nconst showSearchResults = (emojiContainer, searchResultsContainer) => {\n    searchResultsContainer.classList.remove('hidden');\n    emojiContainer.classList.add('hidden');\n};\n\n/**\n * Hide the search result container and show the emojis container.\n *\n * @param {Element} emojiContainer The emojis container\n * @param {Element} searchResultsContainer The search results container\n * @param {Element} searchInput The search input\n */\nconst clearSearch = (emojiContainer, searchResultsContainer, searchInput) => {\n    searchResultsContainer.classList.add('hidden');\n    emojiContainer.classList.remove('hidden');\n    searchInput.value = '';\n};\n\n/**\n * Build function to handle mouse hovering an emoji. Shows the preview.\n *\n * @param {Element} emojiPreview The emoji preview element\n * @param {Element} emojiShortName The emoji short name element\n * @return {Function}\n */\nconst getHandleMouseEnter = (emojiPreview, emojiShortName) => {\n    return (e) => {\n        const target = e.target;\n        if (isEmojiElement(target)) {\n            emojiShortName.textContent = target.getAttribute('data-short-names');\n            emojiPreview.textContent = target.textContent;\n        }\n    };\n};\n\n/**\n * Build function to handle mouse leaving an emoji. Removes the preview.\n *\n * @param {Element} emojiPreview The emoji preview element\n * @param {Element} emojiShortName The emoji short name element\n * @return {Function}\n */\nconst getHandleMouseLeave = (emojiPreview, emojiShortName) => {\n    return (e) => {\n        const target = e.target;\n        if (isEmojiElement(target)) {\n            emojiShortName.textContent = '';\n            emojiPreview.textContent = '';\n        }\n    };\n};\n\n/**\n * Build the function to handle a user clicking something in the picker.\n *\n * The function currently handles clicking on the category selector or selecting\n * a specific emoji.\n *\n * @param {Number} recentEmojiRowCount Number of rows of recent emojis\n * @param {Element} emojiContainer Container element for the visible of emojis\n * @param {Element} searchResultsContainer Contaienr element for the search results\n * @param {Element} searchInput Search input element\n * @param {Function} selectCallback Callback function to execute when a user selects an emoji\n * @param {Function} renderAtPosition Render function to display current visible emojis\n * @return {Function}\n */\nconst getHandleClick = (\n    recentEmojiRowCount,\n    emojiContainer,\n    searchResultsContainer,\n    searchInput,\n    selectCallback,\n    renderAtPosition\n) => {\n    return (e, rowData, categoryScrollPositions) => {\n        const target = e.target;\n        let newRowData = rowData;\n        let newCategoryScrollPositions = categoryScrollPositions;\n\n        // Hide the search results if they are visible.\n        clearSearch(emojiContainer, searchResultsContainer, searchInput);\n\n        if (isEmojiElement(target)) {\n            // Emoji selected.\n            const unified = target.getAttribute('data-unified');\n            const shortnames = target.getAttribute('data-short-names').replace(/:/g, '').split(' ');\n            // Build the emoji data from the selected element.\n            const emojiData = {unified, shortnames};\n            const currentScrollTop = emojiContainer.scrollTop;\n            const isRecentEmojiRowVisible = emojiContainer.querySelector(`[data-row=\"${recentEmojiRowCount - 1}\"]`) !== null;\n            // Save the selected emoji in the recent emojis list.\n            [newRowData, recentEmojiRowCount] = addRecentEmoji(rowData, recentEmojiRowCount, emojiData);\n            // Re-index the category scroll positions because the additional recent emoji may have\n            // changed their positions.\n            newCategoryScrollPositions = getCategoryScrollPositionsFromRowData(newRowData);\n\n            if (isRecentEmojiRowVisible) {\n                // If the list of recent emojis is currently visible then we need to re-render the emojis\n                // to update the display and show the newly selected recent emoji.\n                renderAtPosition(currentScrollTop, newRowData);\n            }\n\n            // Call the client's callback function with the selected emoji.\n            selectCallback(target.textContent);\n            // Return the newly calculated row data and scroll positions.\n            return [newRowData, newCategoryScrollPositions];\n        }\n\n        const categorySelector = findCategorySelectorFromElement(target);\n        if (categorySelector) {\n            // Category selector.\n            const selectedCategory = categorySelector.getAttribute('data-category');\n            const position = categoryScrollPositions[selectedCategory];\n            // Scroll the container to the selected category. This will trigger the\n            // on scroll handler to re-render the visibile emojis.\n            emojiContainer.scrollTop = position;\n        }\n\n        return [newRowData, newCategoryScrollPositions];\n    };\n};\n\n/**\n * Build the function that handles scrolling of the emoji container to display the\n * correct emojis.\n *\n * We render the emoji rows as they are needed rather than all up front so that we\n * can avoid adding tends of thousands of elements to the DOM unnecessarily which\n * would bog down performance.\n *\n * @param {Element} root The picker root element\n * @param {Number} currentVisibleRowScrollPosition The current scroll position of the container\n * @param {Element} emojiContainer The emojis container element\n * @param {Object} initialCategoryScrollPositions Scroll positions for each category\n * @param {Function} renderAtPosition Function to render the appropriate emojis for a scroll position\n * @return {Function}\n */\nconst getHandleScroll = (\n    root,\n    currentVisibleRowScrollPosition,\n    emojiContainer,\n    initialCategoryScrollPositions,\n    renderAtPosition\n) => {\n    // Scope some local variables to track the scroll positions of the categories. We need to\n    // recalculate these because adding recent emojis can change those positions by adding\n    // additional rows.\n    let [\n        currentCategoryElement,\n        previousCategoryPosition,\n        nextCategoryPosition\n    ] = getCategoryByScrollPosition(root, emojiContainer.scrollTop, initialCategoryScrollPositions);\n\n    return (categoryScrollPositions, rowData) => {\n        const newScrollPosition = emojiContainer.scrollTop;\n        const upperScrollBound = currentVisibleRowScrollPosition + ROW_HEIGHT_RAW;\n        const lowerScrollBound = currentVisibleRowScrollPosition - ROW_HEIGHT_RAW;\n        // We only need to update the active category indicator if the user has scrolled into a\n        // new category scroll position.\n        const updateActiveCategory = (newScrollPosition >= nextCategoryPosition) ||\n                       (newScrollPosition < previousCategoryPosition);\n        // We only need to render new emoji rows if the user has scrolled far enough that a new row\n        // would be visible (i.e. they've scrolled up or down more than 40px - the height of a row).\n        const updateRenderRows = (newScrollPosition < lowerScrollBound) || (newScrollPosition > upperScrollBound);\n\n        if (updateActiveCategory) {\n            // New category is visible so update the active category selector and re-index the\n            // positions incase anything has changed.\n            [\n                currentCategoryElement,\n                previousCategoryPosition,\n                nextCategoryPosition\n            ] = getCategoryByScrollPosition(root, newScrollPosition, categoryScrollPositions);\n            setCategorySelectorActive(root, currentCategoryElement);\n        }\n\n        if (updateRenderRows) {\n            // A new row should be visible so re-render the visible emojis at this new position.\n            // We request an animation frame from the browser so that we're not blocking anything.\n            // The animation only needs to occur as soon as the browser is ready not immediately.\n            requestAnimationFrame(() => {\n                renderAtPosition(newScrollPosition, rowData);\n                // Remember the updated position.\n                currentVisibleRowScrollPosition = newScrollPosition;\n            });\n        }\n    };\n};\n\n/**\n * Build the function that handles search input from the user.\n *\n * @param {Element} searchInput The search input element\n * @param {Element} searchResultsContainer Container element to display the search results\n * @param {Element} emojiContainer Container element for the emoji rows\n * @return {Function}\n */\nconst getHandleSearch = (searchInput, searchResultsContainer, emojiContainer) => {\n    const rowContainer = searchResultsContainer.querySelector(SELECTORS.ROW_CONTAINER);\n    // Build a render function for the search results.\n    const renderSearchResultsAtPosition = generateRenderRowsAtPositionFunction(rowContainer);\n    searchResultsContainer.append(rowContainer);\n\n    return async () => {\n        const searchTerm = searchInput.value;\n\n        if (searchTerm) {\n            // Display the search results container and hide the emojis container.\n            showSearchResults(emojiContainer, searchResultsContainer);\n\n            // Find which emojis match the user's search input.\n            const matchingEmojis = Object.keys(EmojiData.byShortName).reduce((carry, shortName) => {\n                if (shortName.includes(searchTerm)) {\n                    carry.push({\n                        shortnames: [shortName],\n                        unified: EmojiData.byShortName[shortName]\n                    });\n                }\n                return carry;\n            }, []);\n\n            const searchResultsString = await get_string('searchresults', 'core');\n            const rowData = createRowDataForCategory(searchResultsString, matchingEmojis, 0);\n            // Show the emoji rows for the search results.\n            renderSearchResultsAtPosition(0, rowData, rowData.length);\n        } else {\n            // Hide the search container and show the emojis container.\n            clearSearch(emojiContainer, searchResultsContainer, searchInput);\n        }\n    };\n};\n\n/**\n * Register the emoji picker event listeners.\n *\n * @param {Element} root The picker root element\n * @param {Element} emojiContainer Root element containing the list of visible emojis\n * @param {Function} renderAtPosition Function to render the visible emojis at a given scroll position\n * @param {Number} currentVisibleRowScrollPosition What is the current scroll position\n * @param {Function} selectCallback Function to execute when the user picks an emoji\n * @param {Object} categoryScrollPositions Scroll positions for where each of the emoji categories begin\n * @param {Array} rowData Data representing each of the display rows for hte emoji container\n * @param {Number} recentEmojiRowCount Number of rows of recent emojis\n */\nconst registerEventListeners = (\n    root,\n    emojiContainer,\n    renderAtPosition,\n    currentVisibleRowScrollPosition,\n    selectCallback,\n    categoryScrollPositions,\n    rowData,\n    recentEmojiRowCount\n) => {\n    const searchInput = root.querySelector(SELECTORS.SEARCH_INPUT);\n    const searchResultsContainer = root.querySelector(SELECTORS.SEARCH_RESULTS_CONTAINER);\n    const emojiPreview = root.querySelector(SELECTORS.EMOJI_PREVIEW);\n    const emojiShortName = root.querySelector(SELECTORS.EMOJI_SHORT_NAME);\n    // Build the click handler function.\n    const clickHandler = getHandleClick(\n        recentEmojiRowCount,\n        emojiContainer,\n        searchResultsContainer,\n        searchInput,\n        selectCallback,\n        renderAtPosition\n    );\n    // Build the scroll handler function.\n    const scrollHandler = getHandleScroll(\n        root,\n        currentVisibleRowScrollPosition,\n        emojiContainer,\n        categoryScrollPositions,\n        renderAtPosition\n    );\n    const searchHandler = getHandleSearch(searchInput, searchResultsContainer, emojiContainer);\n\n    // Mouse enter/leave events to show the emoji preview on hover or focus.\n    root.addEventListener('focus', getHandleMouseEnter(emojiPreview, emojiShortName), true);\n    root.addEventListener('blur', getHandleMouseLeave(emojiPreview, emojiShortName), true);\n    root.addEventListener('mouseenter', getHandleMouseEnter(emojiPreview, emojiShortName), true);\n    root.addEventListener('mouseleave', getHandleMouseLeave(emojiPreview, emojiShortName), true);\n    // User selects an emoji or clicks on one of the emoji category selectors.\n    root.addEventListener('click', e => {\n        // Update the row data and category scroll positions because they may have changes if the\n        // user selects an emoji which updates the recent emojis list.\n        [rowData, categoryScrollPositions] = clickHandler(e, rowData, categoryScrollPositions);\n    });\n    // Throttle the scroll event to only execute once every 50 milliseconds to prevent performance issues\n    // in the browser when re-rendering the picker emojis. The scroll event fires a lot otherwise.\n    emojiContainer.addEventListener('scroll', throttle(() => scrollHandler(categoryScrollPositions, rowData), 50));\n    // Debounce the search input so that it only executes 200 milliseconds after the user has finished typing.\n    searchInput.addEventListener('input', debounce(searchHandler, 200));\n};\n\n/**\n * Initialise the emoji picker.\n *\n * @param {Element} root The root element for the picker\n * @param {Function} selectCallback Callback for when the user selects an emoji\n */\nexport default (root, selectCallback) => {\n    const emojiContainer = root.querySelector(SELECTORS.EMOJIS_CONTAINER);\n    const rowContainer = emojiContainer.querySelector(SELECTORS.ROW_CONTAINER);\n    const recentEmojis = getRecentEmojis();\n    // Add the recent emojis category to the list of standard categories.\n    const allData = [{\n        name: 'Recent',\n        emojis: recentEmojis\n    }, ...EmojiData.byCategory];\n    let rowData = [];\n    let recentEmojiRowCount = 0;\n\n    /**\n     * Split categories data into rows which represent how they will be displayed in the\n     * picker. Each category will add a row containing the display name for the category\n     * and a row for every 9 emojis in the category. The row data will be used to calculate\n     * which emojis should be visible in the picker at any given time.\n     *\n     * E.g.\n     * input = [\n     *  {name: 'example1', emojis: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]},\n     *  {name: 'example2', emojis: [13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23]},\n     * ]\n     * output = [\n     *      {type: 'categoryName': data: 'Example 1'},\n     *      {type: 'emojiRow': data: [1, 2, 3, 4, 5, 6, 7, 8, 9]},\n     *      {type: 'emojiRow': data: [10, 11, 12]},\n     *      {type: 'categoryName': data: 'Example 2'},\n     *      {type: 'emojiRow': data: [13, 14, 15, 16, 17, 18, 19, 20, 21]},\n     *      {type: 'emojiRow': data: [22, 23]},\n     * ]\n     */\n    allData.forEach(category => {\n        const categorySelector = getCategorySelectorByCategoryName(root, category.name);\n        // Get the display name from the category selector button so that we don't need to\n        // send an ajax request for the string.\n        const categoryDisplayName = categorySelector.title;\n        const categoryRowData = createRowDataForCategory(categoryDisplayName, category.emojis, rowData.length);\n\n        if (category.name === 'Recent') {\n            // Remember how many recent emoji rows there are because it needs to be used to\n            // re-index the row data later when we're adding more recent emojis.\n            recentEmojiRowCount = categoryRowData.length;\n        }\n\n        rowData = rowData.concat(categoryRowData);\n    });\n\n    // Index the row data so that we can calculate which rows should be visible.\n    rowData = addIndexesToRowData(rowData);\n    // Calculate the scroll positions for each of the categories within the emoji container.\n    // These are used to know where to jump to when the user selects a specific category.\n    const categoryScrollPositions = getCategoryScrollPositionsFromRowData(rowData);\n    const renderAtPosition = generateRenderRowsAtPositionFunction(rowContainer);\n    // Display the initial set of emojis.\n    renderAtPosition(0, rowData);\n\n    registerEventListeners(\n        root,\n        emojiContainer,\n        renderAtPosition,\n        0,\n        selectCallback,\n        categoryScrollPositions,\n        rowData,\n        recentEmojiRowCount\n    );\n};"],"file":"picker.min.js"}