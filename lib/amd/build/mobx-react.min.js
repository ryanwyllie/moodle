'use strict';var _typeof2='function'==typeof Symbol&&'symbol'==typeof Symbol.iterator?function(obj){return typeof obj}:function(obj){return obj&&'function'==typeof Symbol&&obj.constructor===Symbol&&obj!==Symbol.prototype?'symbol':typeof obj};(function(global,factory){'object'===('undefined'==typeof exports?'undefined':_typeof2(exports))&&'undefined'!=typeof module?factory(exports,require('mobx'),require('react'),require('react-dom')):'function'==typeof define&&define.amd?define('core/mobx-react',['exports','core/mobx','core/react','core/react-dom'],factory):factory(global.mobxReact={},global.mobx,global.React,global.ReactDOM)})(void 0,function(exports,mobx,React,reactDom){'use strict';function createChainableTypeChecker(validate){function checkType(isRequired,props,propName,componentName,location,propFullName){for(var _len=arguments.length,rest=Array(6<_len?_len-6:0),_key=6;_key<_len;_key++)rest[_key-6]=arguments[_key];return mobx.untracked(function(){if(componentName=componentName||'<<anonymous>>',propFullName=propFullName||propName,null==props[propName]){if(isRequired){var actual=null===props[propName]?'null':'undefined';return new Error('The '+location+' `'+propFullName+'` is marked as required in `'+componentName+'`, but its value is `'+actual+'`.')}return null}return validate.apply(void 0,[props,propName,componentName,location,propFullName].concat(rest))})}var chainedCheckType=checkType.bind(null,!1);return chainedCheckType.isRequired=checkType.bind(null,!0),chainedCheckType}function isSymbol(propType,propValue){return'symbol'===propType||'Symbol'===propValue['@@toStringTag']||!!('function'==typeof Symbol&&propValue instanceof Symbol)}function getPropType(propValue){var propType='undefined'==typeof propValue?'undefined':_typeof(propValue);return Array.isArray(propValue)?'array':propValue instanceof RegExp?'object':isSymbol(propType,propValue)?'symbol':propType}function getPreciseType(propValue){var propType=getPropType(propValue);if('object'===propType){if(propValue instanceof Date)return'date';if(propValue instanceof RegExp)return'regexp'}return propType}function createObservableTypeCheckerCreator(allowNativeType,mobxType){return createChainableTypeChecker(function(props,propName,componentName,location,propFullName){return mobx.untracked(function(){if(allowNativeType&&getPropType(props[propName])===mobxType.toLowerCase())return null;var mobxChecker;switch(mobxType){case'Array':mobxChecker=mobx.isObservableArray;break;case'Object':mobxChecker=mobx.isObservableObject;break;case'Map':mobxChecker=mobx.isObservableMap;break;default:throw new Error('Unexpected mobxType: '+mobxType);}var propValue=props[propName];if(!mobxChecker(propValue)){var preciseType=getPreciseType(propValue),nativeTypeExpectationMessage=allowNativeType?' or javascript `'+mobxType.toLowerCase()+'`':'';return new Error('Invalid prop `'+propFullName+'` of type `'+preciseType+'` supplied to `'+componentName+'`, expected `mobx.Observable'+mobxType+'`'+nativeTypeExpectationMessage+'.')}return null})})}function createObservableArrayOfTypeChecker(allowNativeType,typeChecker){return createChainableTypeChecker(function(props,propName,componentName,location,propFullName){for(var _len2=arguments.length,rest=Array(5<_len2?_len2-5:0),_key2=5;_key2<_len2;_key2++)rest[_key2-5]=arguments[_key2];return mobx.untracked(function(){if('function'!=typeof typeChecker)return new Error('Property `'+propFullName+'` of component `'+componentName+'` has invalid PropType notation.');var error=createObservableTypeCheckerCreator(allowNativeType,'Array')(props,propName,componentName);if(error instanceof Error)return error;for(var propValue=props[propName],i=0;i<propValue.length;i++)if(error=typeChecker.apply(void 0,[propValue,i,componentName,location,propFullName+'['+i+']'].concat(rest)),error instanceof Error)return error;return null})})}function isStateless(component){return!(component.prototype&&component.prototype.render)}function createStoreInjector(grabStoresFn,component,injectNames){var _class,_temp2,displayName='inject-'+(component.displayName||component.name||component.constructor&&component.constructor.name||'Unknown');injectNames&&(displayName+='-with-'+injectNames);var Injector=(_temp2=_class=function(_Component){function Injector(){var _ref,_temp,_this,_ret;classCallCheck(this,Injector);for(var _len=arguments.length,args=Array(_len),_key=0;_key<_len;_key++)args[_key]=arguments[_key];return _ret=(_temp=(_this=possibleConstructorReturn(this,(_ref=Injector.__proto__||Object.getPrototypeOf(Injector)).call.apply(_ref,[this].concat(args))),_this),_this.storeRef=function(instance){_this.wrappedInstance=instance},_temp),possibleConstructorReturn(_this,_ret)}return inherits(Injector,_Component),createClass(Injector,[{key:'render',value:function(){var newProps={};for(var key in this.props)this.props.hasOwnProperty(key)&&(newProps[key]=this.props[key]);var additionalProps=grabStoresFn(this.context.mobxStores||{},newProps,this.context)||{};for(var _key2 in additionalProps)newProps[_key2]=additionalProps[_key2];return isStateless(component)||(newProps.ref=this.storeRef),React.createElement(component,newProps)}}]),Injector}(React.Component),_class.displayName=displayName,_temp2);return hoistNonReactStatics(Injector,component),Injector.wrappedComponent=component,Object.defineProperties(Injector,proxiedInjectorProps),Injector}function grabStoresByName(storeNames){return function(baseStores,nextProps){return storeNames.forEach(function(storeName){if(!(storeName in nextProps)){if(!(storeName in baseStores))throw new Error('MobX injector: Store \''+storeName+'\' is not available! Make sure it is provided by some Provider');nextProps[storeName]=baseStores[storeName]}}),nextProps}}function inject(){var grabStoresFn;if('function'==typeof arguments[0])return grabStoresFn=arguments[0],function(componentClass){var injected=createStoreInjector(grabStoresFn,componentClass);return injected.isMobxInjector=!1,injected=observer(injected),injected.isMobxInjector=!0,injected};for(var storeNames=[],i=0;i<arguments.length;i++)storeNames[i]=arguments[i];return grabStoresFn=grabStoresByName(storeNames),function(componentClass){return createStoreInjector(grabStoresFn,componentClass,storeNames.join('-'))}}function createSymbol(name){return'function'==typeof Symbol?Symbol(name):'$mobxReactProp$'+name+Math.random()}function setHiddenProp(target,prop,value){Object.hasOwnProperty(target,prop)?target[prop]=value:Object.defineProperty(target,prop,{enumerable:!1,configurable:!0,writeable:!0,value:value})}function findDOMNode$2(component){if(reactDom.findDOMNode)try{return reactDom.findDOMNode(component)}catch(e){return null}return null}function reportRendering(component){var node=findDOMNode$2(component);node&&componentByNodeRegistry&&componentByNodeRegistry.set(node,component),renderReporter.emit({event:'render',renderTime:component.__$mobRenderEnd-component.__$mobRenderStart,totalTime:Date.now()-component.__$mobRenderStart,component:component,node:node})}function trackComponents(){if('undefined'==typeof WeakMap)throw new Error('[mobx-react] tracking components is not supported in this browser.');isDevtoolsEnabled||(isDevtoolsEnabled=!0)}function useStaticRendering(useStaticRendering){isUsingStaticRendering=useStaticRendering}function patch(target,funcName){var runMixinFirst=!!(2<arguments.length&&void 0!==arguments[2])&&arguments[2],base=target[funcName],mixinFunc=reactiveMixin[funcName],f=base?!0===runMixinFirst?function(){mixinFunc.apply(this,arguments),base.apply(this,arguments)}:function(){base.apply(this,arguments),mixinFunc.apply(this,arguments)}:mixinFunc;target[funcName]=f}function shallowEqual(objA,objB){if(is(objA,objB))return!0;if('object'!==('undefined'==typeof objA?'undefined':_typeof(objA))||null===objA||'object'!==('undefined'==typeof objB?'undefined':_typeof(objB))||null===objB)return!1;var keysA=Object.keys(objA),keysB=Object.keys(objB);if(keysA.length!==keysB.length)return!1;for(var i=0;i<keysA.length;i++)if(!hasOwnProperty.call(objB,keysA[i])||!is(objA[keysA[i]],objB[keysA[i]]))return!1;return!0}function is(x,y){return x===y?0!==x||1/x==1/y:x!==x&&y!==y}function makeComponentReactive(render){function reactiveRender(){var _this=this;isRenderingPending=!1;var exception=void 0,rendering=void 0;if(reaction.track(function(){isDevtoolsEnabled&&(_this.__$mobRenderStart=Date.now());try{rendering=mobx._allowStateChanges(!1,baseRender)}catch(e){exception=e}isDevtoolsEnabled&&(_this.__$mobRenderEnd=Date.now())}),exception)throw errorsReporter.emit(exception),exception;return rendering}var _this2=this;if(!0===isUsingStaticRendering)return render.call(this);var initialName=this.displayName||this.name||this.constructor&&(this.constructor.displayName||this.constructor.name)||'<component>',rootNodeID=this._reactInternalInstance&&this._reactInternalInstance._rootNodeID||this._reactInternalInstance&&this._reactInternalInstance._debugID||this._reactInternalFiber&&this._reactInternalFiber._debugID;setHiddenProp(this,skipRenderKey,!1),setHiddenProp(this,isForcingUpdateKey,!1);var baseRender=render.bind(this),isRenderingPending=!1,reaction=new mobx.Reaction(initialName+'#'+rootNodeID+'.render()',function(){if(!isRenderingPending&&(isRenderingPending=!0,'function'==typeof _this2.componentWillReact&&_this2.componentWillReact(),!0!==_this2.__$mobxIsUnmounted)){var hasError=!0;try{setHiddenProp(_this2,isForcingUpdateKey,!0),_this2[skipRenderKey]||React.Component.prototype.forceUpdate.call(_this2),hasError=!1}finally{setHiddenProp(_this2,isForcingUpdateKey,!1),hasError&&reaction.dispose()}}});return reaction.reactComponent=this,reactiveRender[mobxAdminProperty]=reaction,this.render=reactiveRender,reactiveRender.call(this)}function makeObservableProp(target,propName){function getAtom(){return this[atomHolderKey]||setHiddenProp(this,atomHolderKey,mobx.createAtom('reactive '+propName)),this[atomHolderKey]}var valueHolderKey=createSymbol(propName+' value holder'),atomHolderKey=createSymbol(propName+' atom holder');Object.defineProperty(target,propName,{configurable:!0,enumerable:!0,get:function(){return getAtom.call(this).reportObserved(),this[valueHolderKey]},set:function(v){this[isForcingUpdateKey]||shallowEqual(this[valueHolderKey],v)?setHiddenProp(this,valueHolderKey,v):(setHiddenProp(this,valueHolderKey,v),setHiddenProp(this,skipRenderKey,!0),getAtom.call(this).reportChanged(),setHiddenProp(this,skipRenderKey,!1))}})}function observer(arg1,arg2){if('string'==typeof arg1)throw new Error('Store names should be provided as array');if(Array.isArray(arg1))return warnedAboutObserverInjectDeprecation||(warnedAboutObserverInjectDeprecation=!0,console.warn('Mobx observer: Using observer to inject stores is deprecated since 4.0. Use `@inject("store1", "store2") @observer ComponentClass` or `inject("store1", "store2")(observer(componentClass))` instead of `@observer(["store1", "store2"]) ComponentClass`')),arg2?inject.apply(null,arg1)(observer(arg2)):function(componentClass){return observer(arg1,componentClass)};var componentClass=arg1;if(!0===componentClass.isMobxInjector&&console.warn('Mobx observer: You are trying to use \'observer\' on a component that already has \'inject\'. Please apply \'observer\' before applying \'inject\''),componentClass.__proto__===React.PureComponent&&console.warn('Mobx observer: You are using \'observer\' on React.PureComponent. These two achieve two opposite goals and should not be used together'),'function'==typeof componentClass&&(!componentClass.prototype||!componentClass.prototype.render)&&!componentClass.isReactClass&&!React.Component.isPrototypeOf(componentClass)){var _class,_temp,observerComponent=observer((_temp=_class=function(_Component){function _class(){return classCallCheck(this,_class),possibleConstructorReturn(this,(_class.__proto__||Object.getPrototypeOf(_class)).apply(this,arguments))}return inherits(_class,_Component),createClass(_class,[{key:'render',value:function(){return componentClass.call(this,this.props,this.context)}}]),_class}(React.Component),_class.displayName=componentClass.displayName||componentClass.name,_class.contextTypes=componentClass.contextTypes,_class.propTypes=componentClass.propTypes,_class.defaultProps=componentClass.defaultProps,_temp));return hoistNonReactStatics(observerComponent,componentClass),observerComponent}if(!componentClass)throw new Error('Please pass a valid component to \'observer\'');var target=componentClass.prototype||componentClass;mixinLifecycleEvents(target),componentClass.isMobXReactObserver=!0,makeObservableProp(target,'props'),makeObservableProp(target,'state');var baseRender=target.render;return target.render=function(){return makeComponentReactive.call(this,baseRender)},componentClass}function mixinLifecycleEvents(target){['componentDidMount','componentWillUnmount','componentDidUpdate'].forEach(function(funcName){patch(target,funcName)}),target.shouldComponentUpdate?target.shouldComponentUpdate!==reactiveMixin.shouldComponentUpdate&&console.warn('Use `shouldComponentUpdate` in an `observer` based component breaks the behavior of `observer` and might lead to unexpected results. Manually implementing `sCU` should not be needed when using mobx-react.'):target.shouldComponentUpdate=reactiveMixin.shouldComponentUpdate}function componentWillMount(){var state=this.constructor.getDerivedStateFromProps(this.props,this.state);null!==state&&void 0!==state&&this.setState(state)}function componentWillReceiveProps(nextProps){var state=this.constructor.getDerivedStateFromProps(nextProps,this.state);null!==state&&void 0!==state&&this.setState(state)}function componentWillUpdate(nextProps,nextState){try{var prevProps=this.props,prevState=this.state;this.props=nextProps,this.state=nextState,this.__reactInternalSnapshotFlag=!0,this.__reactInternalSnapshot=this.getSnapshotBeforeUpdate(prevProps,prevState)}finally{this.props=prevProps,this.state=prevState}}var React__default='default'in React?React['default']:React,commonjsGlobal='undefined'==typeof window?'undefined'==typeof global?'undefined'==typeof self?{}:self:global:window,hoistNonReactStatics=function(fn,module){return module={exports:{}},fn(module,module.exports),module.exports}(function(module){(function(global,factory){module.exports=factory()})(commonjsGlobal,function(){var REACT_STATICS={childContextTypes:!0,contextTypes:!0,defaultProps:!0,displayName:!0,getDefaultProps:!0,getDerivedStateFromProps:!0,mixins:!0,propTypes:!0,type:!0},KNOWN_STATICS={name:!0,length:!0,prototype:!0,caller:!0,callee:!0,arguments:!0,arity:!0},defineProperty=Object.defineProperty,getOwnPropertyNames=Object.getOwnPropertyNames,getOwnPropertySymbols=Object.getOwnPropertySymbols,getOwnPropertyDescriptor=Object.getOwnPropertyDescriptor,getPrototypeOf=Object.getPrototypeOf,objectPrototype=getPrototypeOf&&getPrototypeOf(Object);return function hoistNonReactStatics(targetComponent,sourceComponent,blacklist){if('string'!=typeof sourceComponent){if(objectPrototype){var inheritedComponent=getPrototypeOf(sourceComponent);inheritedComponent&&inheritedComponent!==objectPrototype&&hoistNonReactStatics(targetComponent,inheritedComponent,blacklist)}var keys=getOwnPropertyNames(sourceComponent);getOwnPropertySymbols&&(keys=keys.concat(getOwnPropertySymbols(sourceComponent)));for(var key,i=0;i<keys.length;++i)if(key=keys[i],!REACT_STATICS[key]&&!KNOWN_STATICS[key]&&(!blacklist||!blacklist[key])){var descriptor=getOwnPropertyDescriptor(sourceComponent,key);try{defineProperty(targetComponent,key,descriptor)}catch(e){}}return targetComponent}return targetComponent}})}),_typeof='function'==typeof Symbol&&'symbol'===_typeof2(Symbol.iterator)?function(obj){return'undefined'==typeof obj?'undefined':_typeof2(obj)}:function(obj){return obj&&'function'==typeof Symbol&&obj.constructor===Symbol&&obj!==Symbol.prototype?'symbol':'undefined'==typeof obj?'undefined':_typeof2(obj)},asyncGenerator=function(){function AwaitValue(value){this.value=value}function AsyncGenerator(gen){function resume(key,arg){try{var result=gen[key](arg),value=result.value;value instanceof AwaitValue?Promise.resolve(value.value).then(function(arg){resume('next',arg)},function(arg){resume('throw',arg)}):settle(result.done?'return':'normal',result.value)}catch(err){settle('throw',err)}}function settle(type,value){'return'===type?front.resolve({value:value,done:!0}):'throw'===type?front.reject(value):front.resolve({value:value,done:!1}),front=front.next,front?resume(front.key,front.arg):back=null}var front,back;this._invoke=function(key,arg){return new Promise(function(resolve,reject){var request={key:key,arg:arg,resolve:resolve,reject:reject,next:null};back?back=back.next=request:(front=back=request,resume(key,arg))})},'function'!=typeof gen.return&&(this.return=void 0)}return'function'==typeof Symbol&&Symbol.asyncIterator&&(AsyncGenerator.prototype[Symbol.asyncIterator]=function(){return this}),AsyncGenerator.prototype.next=function(arg){return this._invoke('next',arg)},AsyncGenerator.prototype.throw=function(arg){return this._invoke('throw',arg)},AsyncGenerator.prototype.return=function(arg){return this._invoke('return',arg)},{wrap:function wrap(fn){return function(){return new AsyncGenerator(fn.apply(this,arguments))}},await:function _await(value){return new AwaitValue(value)}}}(),classCallCheck=function(instance,Constructor){if(!(instance instanceof Constructor))throw new TypeError('Cannot call a class as a function')},createClass=function(){function defineProperties(target,props){for(var descriptor,i=0;i<props.length;i++)descriptor=props[i],descriptor.enumerable=descriptor.enumerable||!1,descriptor.configurable=!0,'value'in descriptor&&(descriptor.writable=!0),Object.defineProperty(target,descriptor.key,descriptor)}return function(Constructor,protoProps,staticProps){return protoProps&&defineProperties(Constructor.prototype,protoProps),staticProps&&defineProperties(Constructor,staticProps),Constructor}}(),inherits=function(subClass,superClass){if('function'!=typeof superClass&&null!==superClass)throw new TypeError('Super expression must either be null or a function, not '+('undefined'==typeof superClass?'undefined':_typeof2(superClass)));subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:!1,writable:!0,configurable:!0}}),superClass&&(Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass)},possibleConstructorReturn=function(self,call){if(!self)throw new ReferenceError('this hasn\'t been initialised - super() hasn\'t been called');return call&&('object'===('undefined'==typeof call?'undefined':_typeof2(call))||'function'==typeof call)?call:self},EventEmitter=function(){function EventEmitter(){classCallCheck(this,EventEmitter),this.listeners=[]}return createClass(EventEmitter,[{key:'on',value:function(cb){var _this=this;return this.listeners.push(cb),function(){var index=_this.listeners.indexOf(cb);-1!==index&&_this.listeners.splice(index,1)}}},{key:'emit',value:function(data){this.listeners.forEach(function(fn){return fn(data)})}}]),EventEmitter}(),observableArray=createObservableTypeCheckerCreator(!1,'Array'),observableArrayOf=createObservableArrayOfTypeChecker.bind(null,!1),observableMap=createObservableTypeCheckerCreator(!1,'Map'),observableObject=createObservableTypeCheckerCreator(!1,'Object'),arrayOrObservableArray=createObservableTypeCheckerCreator(!0,'Array'),arrayOrObservableArrayOf=createObservableArrayOfTypeChecker.bind(null,!0),objectOrObservableObject=createObservableTypeCheckerCreator(!0,'Object'),propTypes=Object.freeze({observableArray:observableArray,observableArrayOf:observableArrayOf,observableMap:observableMap,observableObject:observableObject,arrayOrObservableArray:arrayOrObservableArray,arrayOrObservableArrayOf:arrayOrObservableArrayOf,objectOrObservableObject:objectOrObservableObject}),injectorContextTypes={mobxStores:objectOrObservableObject};Object.seal(injectorContextTypes);var proxiedInjectorProps={contextTypes:{get:function(){return injectorContextTypes},set:function(){console.warn('Mobx Injector: you are trying to attach `contextTypes` on an component decorated with `inject` (or `observer`) HOC. Please specify the contextTypes on the wrapped component instead. It is accessible through the `wrappedComponent`')},configurable:!0,enumerable:!1},isMobxInjector:{value:!0,writable:!0,configurable:!0,enumerable:!0}},mobxAdminProperty=mobx.$mobx||'$mobx',isDevtoolsEnabled=!1,isUsingStaticRendering=!1,warnedAboutObserverInjectDeprecation=!1,componentByNodeRegistry='undefined'==typeof WeakMap?void 0:new WeakMap,renderReporter=new EventEmitter,skipRenderKey=createSymbol('skipRender'),isForcingUpdateKey=createSymbol('isForcingUpdate'),errorsReporter=new EventEmitter,reactiveMixin={componentWillUnmount:function(){if(!0!==isUsingStaticRendering&&(this.render[mobxAdminProperty]&&this.render[mobxAdminProperty].dispose(),this.__$mobxIsUnmounted=!0,isDevtoolsEnabled)){var node=findDOMNode$2(this);node&&componentByNodeRegistry&&componentByNodeRegistry.delete(node),renderReporter.emit({event:'destroy',component:this,node:node})}},componentDidMount:function(){isDevtoolsEnabled&&reportRendering(this)},componentDidUpdate:function(){isDevtoolsEnabled&&reportRendering(this)},shouldComponentUpdate:function(nextProps,nextState){return isUsingStaticRendering&&console.warn('[mobx-react] It seems that a re-rendering of a React component is triggered while in static (server-side) mode. Please make sure components are rendered only once server-side.'),this.state!==nextState||!shallowEqual(this.props,nextProps)}},Observer=observer(function(_ref){var children=_ref.children,observerInject=_ref.inject,render=_ref.render,component=children||render;if('undefined'==typeof component)return null;if(!observerInject)return component();console.warn('<Observer inject=.../> is no longer supported. Please use inject on the enclosing component instead');var InjectComponent=inject(observerInject)(component);return React__default.createElement(InjectComponent,null)});Observer.displayName='Observer';var ObserverPropsCheck=function(props,key,componentName,location,propFullName){var extraKey='children'===key?'render':'children';return'function'==typeof props[key]&&'function'==typeof props[extraKey]?new Error('Invalid prop,do not use children and render in the same time in`'+componentName):'function'==typeof props[key]||'function'==typeof props[extraKey]?void 0:new Error('Invalid prop `'+propFullName+'` of type `'+_typeof(props[key])+'` supplied to `'+componentName+'`, expected `function`.')};Observer.propTypes={render:ObserverPropsCheck,children:ObserverPropsCheck},componentWillMount.__suppressDeprecationWarning=!0,componentWillReceiveProps.__suppressDeprecationWarning=!0,componentWillUpdate.__suppressDeprecationWarning=!0;var _class,_temp,specialReactKeys={children:!0,key:!0,ref:!0},Provider=(_temp=_class=function(_Component){function Provider(props,context){classCallCheck(this,Provider);var _this=possibleConstructorReturn(this,(Provider.__proto__||Object.getPrototypeOf(Provider)).call(this,props,context));return _this.state=props||{},_this}return inherits(Provider,_Component),createClass(Provider,[{key:'render',value:function(){return React.Children.only(this.props.children)}},{key:'getChildContext',value:function(){var stores={},baseStores=this.context.mobxStores;if(baseStores)for(var key in baseStores)stores[key]=baseStores[key];for(var _key in this.state)specialReactKeys[_key]||'suppressChangedStoreWarning'===_key||(stores[_key]=this.props[_key]);return{mobxStores:stores}}}],[{key:'getDerivedStateFromProps',value:function(nextProps,prevState){if(!nextProps)return null;if(!prevState)return nextProps;if(Object.keys(nextProps).length!==Object.keys(prevState).length&&console.warn('MobX Provider: The set of provided stores has changed. Please avoid changing stores as the change might not propagate to all children'),!nextProps.suppressChangedStoreWarning)for(var key in nextProps)specialReactKeys[key]||prevState[key]===nextProps[key]||console.warn('MobX Provider: Provided store \''+key+'\' has changed. Please avoid replacing stores as the change might not propagate to all children');return nextProps}}]),Provider}(React.Component),_class.contextTypes={mobxStores:objectOrObservableObject},_class.childContextTypes={mobxStores:objectOrObservableObject.isRequired},_temp);if(function(Component$$1){var prototype=Component$$1.prototype;if(!prototype||!prototype.isReactComponent)throw new Error('Can only polyfill class components');if('function'!=typeof Component$$1.getDerivedStateFromProps&&'function'!=typeof prototype.getSnapshotBeforeUpdate)return Component$$1;var foundWillMountName=null,foundWillReceivePropsName=null,foundWillUpdateName=null;if('function'==typeof prototype.componentWillMount?foundWillMountName='componentWillMount':'function'==typeof prototype.UNSAFE_componentWillMount&&(foundWillMountName='UNSAFE_componentWillMount'),'function'==typeof prototype.componentWillReceiveProps?foundWillReceivePropsName='componentWillReceiveProps':'function'==typeof prototype.UNSAFE_componentWillReceiveProps&&(foundWillReceivePropsName='UNSAFE_componentWillReceiveProps'),'function'==typeof prototype.componentWillUpdate?foundWillUpdateName='componentWillUpdate':'function'==typeof prototype.UNSAFE_componentWillUpdate&&(foundWillUpdateName='UNSAFE_componentWillUpdate'),null!=foundWillMountName||null!=foundWillReceivePropsName||null!=foundWillUpdateName){var componentName=Component$$1.displayName||Component$$1.name,newApiName='function'==typeof Component$$1.getDerivedStateFromProps?'getDerivedStateFromProps()':'getSnapshotBeforeUpdate()';throw Error('Unsafe legacy lifecycles will not be called for components using new component APIs.\n\n'+componentName+' uses '+newApiName+' but also contains the following legacy lifecycles:'+(null==foundWillMountName?'':'\n  '+foundWillMountName)+(null==foundWillReceivePropsName?'':'\n  '+foundWillReceivePropsName)+(null==foundWillUpdateName?'':'\n  '+foundWillUpdateName)+'\n\nThe above lifecycles should be removed. Learn more about this warning here:\nhttps://fb.me/react-async-component-lifecycle-hooks')}if('function'==typeof Component$$1.getDerivedStateFromProps&&(prototype.componentWillMount=componentWillMount,prototype.componentWillReceiveProps=componentWillReceiveProps),'function'==typeof prototype.getSnapshotBeforeUpdate){if('function'!=typeof prototype.componentDidUpdate)throw new Error('Cannot polyfill getSnapshotBeforeUpdate() for components that do not define componentDidUpdate() on the prototype');prototype.componentWillUpdate=componentWillUpdate;var componentDidUpdate=prototype.componentDidUpdate;prototype.componentDidUpdate=function(prevProps,prevState,maybeSnapshot){var snapshot=this.__reactInternalSnapshotFlag?this.__reactInternalSnapshot:maybeSnapshot;componentDidUpdate.call(this,prevProps,prevState,snapshot)}}return Component$$1}(Provider),!React.Component)throw new Error('mobx-react requires React to be available');if(!mobx.spy)throw new Error('mobx-react requires mobx to be available');'function'!=typeof reactDom.unstable_batchedUpdates||mobx.configure({reactionScheduler:reactDom.unstable_batchedUpdates});if('object'===('undefined'==typeof __MOBX_DEVTOOLS_GLOBAL_HOOK__?'undefined':_typeof(__MOBX_DEVTOOLS_GLOBAL_HOOK__))){var mobx$1={spy:mobx.spy,extras:{getDebugName:mobx.getDebugName}};__MOBX_DEVTOOLS_GLOBAL_HOOK__.injectMobxReact({renderReporter:renderReporter,componentByNodeRegistry:componentByNodeRegistry,componentByNodeRegistery:componentByNodeRegistry,trackComponents:trackComponents},mobx$1)}exports.propTypes=propTypes,exports.PropTypes=propTypes,exports.onError=function(fn){return errorsReporter.on(fn)},exports.observer=observer,exports.Observer=Observer,exports.renderReporter=renderReporter,exports.componentByNodeRegistery=componentByNodeRegistry,exports.componentByNodeRegistry=componentByNodeRegistry,exports.trackComponents=trackComponents,exports.useStaticRendering=useStaticRendering,exports.Provider=Provider,exports.inject=inject,Object.defineProperty(exports,'__esModule',{value:!0})});
//# sourceMappingURL=mobx-react.min.js.map
