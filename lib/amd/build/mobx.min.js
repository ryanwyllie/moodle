"use strict";var _typeof="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(obj){return typeof obj}:function(obj){return obj&&"function"==typeof Symbol&&obj.constructor===Symbol&&obj!==Symbol.prototype?"symbol":typeof obj};(function(f){if("object"===("undefined"==typeof exports?"undefined":_typeof(exports))&&"undefined"!=typeof module)module.exports=f();else if("function"==typeof define&&define.amd)define("core/mobx",[],f);else{var g;g="undefined"==typeof window?"undefined"==typeof global?"undefined"==typeof self?this:self:global:window,g.mobx=f()}})(function(){return function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a="function"==typeof require&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}for(var i="function"==typeof require&&require,o=0;o<r.length;o++)s(r[o]);return s}({1:[function(require,module,exports){(function(process,global){"use strict";function __extends(d,b){function __(){this.constructor=d}extendStatics(d,b),d.prototype=null===b?Object.create(b):(__.prototype=b.prototype,new __)}function __values(o){var m="function"==typeof Symbol&&o[Symbol.iterator],i=0;return m?m.call(o):{next:function next(){return o&&i>=o.length&&(o=void 0),{value:o&&o[i++],done:!o}}}}function __read(o,n){var m="function"==typeof Symbol&&o[Symbol.iterator];if(!m)return o;var r,e,i=m.call(o),ar=[];try{for(;(void 0===n||0<n--)&&!(r=i.next()).done;)ar.push(r.value)}catch(error){e={error:error}}finally{try{r&&!r.done&&(m=i["return"])&&m.call(i)}finally{if(e)throw e.error}}return ar}function __spread(){for(var ar=[],i=0;i<arguments.length;i++)ar=ar.concat(__read(arguments[i]));return ar}function getNextId$$1(){return++globalState$$1.mobxGuid}function fail$1(message){throw invariant$$1(!1,message),"X"}function invariant$$1(check,message){if(!check)throw new Error("[mobx] "+(message||"An invariant failed, however the error is obfuscated because this is an production build."))}function once$$1(func){var invoked=!1;return function(){if(!invoked)return invoked=!0,func.apply(this,arguments)}}function unique$$1(list){var res=[];return list.forEach(function(item){-1===res.indexOf(item)&&res.push(item)}),res}function isObject$$1(value){return null!==value&&"object"===("undefined"==typeof value?"undefined":_typeof(value))}function isPlainObject$$1(value){if(null===value||"object"!==("undefined"==typeof value?"undefined":_typeof(value)))return!1;var proto=Object.getPrototypeOf(value);return proto===Object.prototype||null===proto}function addHiddenProp$$1(object,propName,value){Object.defineProperty(object,propName,{enumerable:!1,writable:!0,configurable:!0,value:value})}function addHiddenFinalProp$$1(object,propName,value){Object.defineProperty(object,propName,{enumerable:!1,writable:!1,configurable:!0,value:value})}function isPropertyConfigurable$$1(object,prop){var descriptor=Object.getOwnPropertyDescriptor(object,prop);return!descriptor||!1!==descriptor.configurable&&!1!==descriptor.writable}function assertPropertyConfigurable$$1(object,prop){"production"===process.env.NODE_ENV||isPropertyConfigurable$$1(object,prop)||fail$1("Cannot make property '"+prop.toString()+"' observable, it is not configurable and writable in the target object")}function createInstanceofPredicate$$1(name,clazz){var propName="isMobX"+name;return clazz.prototype[propName]=!0,function(x){return isObject$$1(x)&&!0===x[propName]}}function isES6Map$$1(thing){return thing instanceof Map}function getMapLikeKeys$$1(map){return isPlainObject$$1(map)?Object.keys(map):Array.isArray(map)?map.map(function(_a){var _b=__read(_a,1),key=_b[0];return key}):isES6Map$$1(map)||isObservableMap$$1(map)?Array.from(map.keys()):fail$1("Cannot get keys from '"+map+"'")}function toPrimitive$$1(value){return null===value?null:"object"===("undefined"==typeof value?"undefined":_typeof(value))?""+value:value}function createAtom$$1(name,onBecomeObservedHandler,onBecomeUnobservedHandler){void 0===onBecomeObservedHandler&&(onBecomeObservedHandler=noop$$1),void 0===onBecomeUnobservedHandler&&(onBecomeUnobservedHandler=noop$$1);var atom=new Atom$$1(name);return onBecomeObserved$$1(atom,onBecomeObservedHandler),onBecomeUnobserved$$1(atom,onBecomeUnobservedHandler),atom}function createPropertyInitializerDescriptor(prop,enumerable){var cache=enumerable?enumerableDescriptorCache:nonEnumerableDescriptorCache;return cache[prop]||(cache[prop]={configurable:!0,enumerable:enumerable,get:function get(){return initializeInstance$$1(this),this[prop]},set:function set(value){initializeInstance$$1(this),this[prop]=value}})}function initializeInstance$$1(target){if(!0!==target[mobxDidRunLazyInitializersSymbol$$1]){var decorators=target[mobxPendingDecorators$$1];if(decorators)for(var key in addHiddenProp$$1(target,mobxDidRunLazyInitializersSymbol$$1,!0),decorators){var d=decorators[key];d.propertyCreator(target,d.prop,d.descriptor,d.decoratorTarget,d.decoratorArguments)}}}function createPropDecorator$$1(propertyInitiallyEnumerable,propertyCreator){return function(){var decoratorArguments,decorator=function(target,prop,descriptor,applyImmediately){if(!0===applyImmediately)return propertyCreator(target,prop,descriptor,target,decoratorArguments),null;if("production"===process.env.NODE_ENV||quacksLikeADecorator$$1(arguments)||fail$1("This function is a decorator, but it wasn't invoked like a decorator"),!Object.prototype.hasOwnProperty.call(target,mobxPendingDecorators$$1)){var inheritedDecorators=target[mobxPendingDecorators$$1];addHiddenProp$$1(target,mobxPendingDecorators$$1,__assign({},inheritedDecorators))}return target[mobxPendingDecorators$$1][prop]={prop:prop,propertyCreator:propertyCreator,descriptor:descriptor,decoratorTarget:target,decoratorArguments:decoratorArguments},createPropertyInitializerDescriptor(prop,propertyInitiallyEnumerable)};return quacksLikeADecorator$$1(arguments)?(decoratorArguments=EMPTY_ARRAY$$1,decorator.apply(null,arguments)):(decoratorArguments=Array.prototype.slice.call(arguments),decorator)}}function quacksLikeADecorator$$1(args){return(2===args.length||3===args.length)&&"string"==typeof args[1]||4===args.length&&!0===args[3]}function deepEnhancer$$1(v,_,name){return isObservable$$1(v)?v:Array.isArray(v)?observable$$1.array(v,{name:name}):isPlainObject$$1(v)?observable$$1.object(v,void 0,{name:name}):isES6Map$$1(v)?observable$$1.map(v,{name:name}):v}function referenceEnhancer$$1(newValue){return newValue}function createDecoratorForEnhancer$$1(enhancer){invariant$$1(enhancer);var decorator=createPropDecorator$$1(!0,function(target,propertyName,descriptor){"production"!==process.env.NODE_ENV&&invariant$$1(!descriptor||!descriptor.get,"@observable cannot be used on getter (property \""+propertyName+"\"), use @computed instead.");var initialValue=descriptor?descriptor.initializer?descriptor.initializer.call(target):descriptor.value:void 0;asObservableObject$$1(target).addObservableProp(propertyName,initialValue,enhancer)}),res="undefined"!=typeof process&&process.env&&"production"!==process.env.NODE_ENV?function(){return 2>arguments.length?fail$1("Incorrect decorator invocation. @observable decorator doesn't expect any arguments"):decorator.apply(null,arguments)}:decorator;return res.enhancer=enhancer,res}function assertValidOption(key){/^(deep|name|defaultDecorator|proxy)$/.test(key)||fail$1("invalid option for (extend)observable: "+key)}function asCreateObservableOptions$$1(thing){if(null===thing||thing===void 0)return defaultCreateObservableOptions$$1;if("string"==typeof thing)return{name:thing,deep:!0,proxy:!0};if("production"!==process.env.NODE_ENV){if("object"!==("undefined"==typeof thing?"undefined":_typeof(thing)))return fail$1("expected options object");Object.keys(thing).forEach(assertValidOption)}return thing}function getEnhancerFromOptions(options){return options.defaultDecorator?options.defaultDecorator.enhancer:!1===options.deep?referenceEnhancer$$1:deepEnhancer$$1}function incorrectlyUsedAsDecorator(methodName){fail$1("Expected one or two arguments to observable."+methodName+". Did you accidentally try to use observable."+methodName+" as decorator?")}function createAction$$1(actionName,fn){"production"!==process.env.NODE_ENV&&(invariant$$1("function"==typeof fn,"`action` can only be invoked on functions"),("string"!=typeof actionName||!actionName)&&fail$1("actions should have valid names, got: '"+actionName+"'"));var res=function(){return executeAction$$1(actionName,fn,this,arguments)};return res.isMobxAction=!0,res}function executeAction$$1(actionName,fn,scope,args){var runInfo=startAction(actionName,fn,scope,args);try{return fn.apply(scope,args)}finally{endAction(runInfo)}}function startAction(actionName,fn,scope,args){var notifySpy=isSpyEnabled$$1()&&!!actionName,startTime=0;if(notifySpy&&"production"!==process.env.NODE_ENV){startTime=Date.now();var l=args&&args.length||0,flattendArgs=Array(l);if(0<l)for(var i=0;i<l;i++)flattendArgs[i]=args[i];spyReportStart$$1({type:"action",name:actionName,object:scope,arguments:flattendArgs})}var prevDerivation=untrackedStart$$1();startBatch$$1();var prevAllowStateChanges=allowStateChangesStart$$1(!0);return{prevDerivation:prevDerivation,prevAllowStateChanges:prevAllowStateChanges,notifySpy:notifySpy,startTime:startTime}}function endAction(runInfo){allowStateChangesEnd$$1(runInfo.prevAllowStateChanges),endBatch$$1(),untrackedEnd$$1(runInfo.prevDerivation),runInfo.notifySpy&&"production"!==process.env.NODE_ENV&&spyReportEnd$$1({time:Date.now()-runInfo.startTime})}function allowStateChanges$$1(allowStateChanges$$1,func){var res,prev=allowStateChangesStart$$1(allowStateChanges$$1);try{res=func()}finally{allowStateChangesEnd$$1(prev)}return res}function allowStateChangesStart$$1(allowStateChanges$$1){var prev=globalState$$1.allowStateChanges;return globalState$$1.allowStateChanges=allowStateChanges$$1,prev}function allowStateChangesEnd$$1(prev){globalState$$1.allowStateChanges=prev}function isCaughtException$$1(e){return e instanceof CaughtException$$1}function shouldCompute$$1(derivation){switch(derivation.dependenciesState){case exports.IDerivationState.UP_TO_DATE:return!1;case exports.IDerivationState.NOT_TRACKING:case exports.IDerivationState.STALE:return!0;case exports.IDerivationState.POSSIBLY_STALE:{for(var obj,prevUntracked=untrackedStart$$1(),obs=derivation.observing,l=obs.length,i=0;i<l;i++)if(obj=obs[i],isComputedValue$$1(obj)){if(globalState$$1.disableErrorBoundaries)obj.get();else try{obj.get()}catch(e){return untrackedEnd$$1(prevUntracked),!0}if(derivation.dependenciesState===exports.IDerivationState.STALE)return untrackedEnd$$1(prevUntracked),!0}return changeDependenciesStateTo0$$1(derivation),untrackedEnd$$1(prevUntracked),!1}}}function checkIfStateModificationsAreAllowed$$1(atom){var hasObservers$$1=0<atom.observers.size;0<globalState$$1.computationDepth&&hasObservers$$1&&fail$1("production"!==process.env.NODE_ENV&&"Computed values are not allowed to cause side effects by changing observables that are already being observed. Tried to modify: "+atom.name),!globalState$$1.allowStateChanges&&(hasObservers$$1||"strict"===globalState$$1.enforceActions)&&fail$1("production"!==process.env.NODE_ENV&&(globalState$$1.enforceActions?"Since strict-mode is enabled, changing observed observable values outside actions is not allowed. Please wrap the code in an `action` if this change is intended. Tried to modify: ":"Side effects like changing state are not allowed at this point. Are you trying to modify state from, for example, the render function of a React component? Tried to modify: ")+atom.name)}function trackDerivedFunction$$1(derivation,f,context){changeDependenciesStateTo0$$1(derivation),derivation.newObserving=Array(derivation.observing.length+100),derivation.unboundDepsCount=0,derivation.runId=++globalState$$1.runId;var prevTracking=globalState$$1.trackingDerivation;globalState$$1.trackingDerivation=derivation;var result;if(!0===globalState$$1.disableErrorBoundaries)result=f.call(context);else try{result=f.call(context)}catch(e){result=new CaughtException$$1(e)}return globalState$$1.trackingDerivation=prevTracking,bindDependencies(derivation),result}function bindDependencies(derivation){for(var dep,prevObserving=derivation.observing,observing=derivation.observing=derivation.newObserving,lowestNewObservingDerivationState=exports.IDerivationState.UP_TO_DATE,i0=0,l=derivation.unboundDepsCount,i=0;i<l;i++)dep=observing[i],0===dep.diffValue&&(dep.diffValue=1,i0!==i&&(observing[i0]=dep),i0++),dep.dependenciesState>lowestNewObservingDerivationState&&(lowestNewObservingDerivationState=dep.dependenciesState);for(observing.length=i0,derivation.newObserving=null,l=prevObserving.length;l--;){var dep=prevObserving[l];0===dep.diffValue&&removeObserver$$1(dep,derivation),dep.diffValue=0}for(;i0--;){var dep=observing[i0];1===dep.diffValue&&(dep.diffValue=0,addObserver$$1(dep,derivation))}lowestNewObservingDerivationState!==exports.IDerivationState.UP_TO_DATE&&(derivation.dependenciesState=lowestNewObservingDerivationState,derivation.onBecomeStale())}function clearObserving$$1(derivation){var obs=derivation.observing;derivation.observing=[];for(var i=obs.length;i--;)removeObserver$$1(obs[i],derivation);derivation.dependenciesState=exports.IDerivationState.NOT_TRACKING}function untracked$$1(action$$1){var prev=untrackedStart$$1();try{return action$$1()}finally{untrackedEnd$$1(prev)}}function untrackedStart$$1(){var prev=globalState$$1.trackingDerivation;return globalState$$1.trackingDerivation=null,prev}function untrackedEnd$$1(prev){globalState$$1.trackingDerivation=prev}function changeDependenciesStateTo0$$1(derivation){if(derivation.dependenciesState!==exports.IDerivationState.UP_TO_DATE){derivation.dependenciesState=exports.IDerivationState.UP_TO_DATE;for(var obs=derivation.observing,i=obs.length;i--;)obs[i].lowestObserverState=exports.IDerivationState.UP_TO_DATE}}function isolateGlobalState$$1(){runInIsolationCalled=!0,getGlobal$$1().__mobxInstanceCount--}function getGlobal$$1(){return"undefined"==typeof window?global:window}function hasObservers$$1(observable$$1){return observable$$1.observers&&0<observable$$1.observers.size}function getObservers$$1(observable$$1){return observable$$1.observers}function addObserver$$1(observable$$1,node){observable$$1.observers.add(node),observable$$1.lowestObserverState>node.dependenciesState&&(observable$$1.lowestObserverState=node.dependenciesState)}function removeObserver$$1(observable$$1,node){observable$$1.observers.delete(node),0===observable$$1.observers.size&&queueForUnobservation$$1(observable$$1)}function queueForUnobservation$$1(observable$$1){!1===observable$$1.isPendingUnobservation&&(observable$$1.isPendingUnobservation=!0,globalState$$1.pendingUnobservations.push(observable$$1))}function startBatch$$1(){globalState$$1.inBatch++}function endBatch$$1(){if(0==--globalState$$1.inBatch){runReactions$$1();for(var observable$$1,list=globalState$$1.pendingUnobservations,i=0;i<list.length;i++)observable$$1=list[i],observable$$1.isPendingUnobservation=!1,0===observable$$1.observers.size&&(observable$$1.isBeingObserved&&(observable$$1.isBeingObserved=!1,observable$$1.onBecomeUnobserved()),observable$$1 instanceof ComputedValue$$1&&observable$$1.suspend());globalState$$1.pendingUnobservations=[]}}function reportObserved$$1(observable$$1){var derivation=globalState$$1.trackingDerivation;return null===derivation?(0===observable$$1.observers.size&&0<globalState$$1.inBatch&&queueForUnobservation$$1(observable$$1),!1):(derivation.runId!==observable$$1.lastAccessedBy&&(observable$$1.lastAccessedBy=derivation.runId,derivation.newObserving[derivation.unboundDepsCount++]=observable$$1,!observable$$1.isBeingObserved&&(observable$$1.isBeingObserved=!0,observable$$1.onBecomeObserved())),!0)}function propagateChanged$$1(observable$$1){observable$$1.lowestObserverState===exports.IDerivationState.STALE||(observable$$1.lowestObserverState=exports.IDerivationState.STALE,observable$$1.observers.forEach(function(d){d.dependenciesState===exports.IDerivationState.UP_TO_DATE&&(d.isTracing!==TraceMode$$1.NONE&&logTraceInfo(d,observable$$1),d.onBecomeStale()),d.dependenciesState=exports.IDerivationState.STALE}))}function propagateChangeConfirmed$$1(observable$$1){observable$$1.lowestObserverState===exports.IDerivationState.STALE||(observable$$1.lowestObserverState=exports.IDerivationState.STALE,observable$$1.observers.forEach(function(d){d.dependenciesState===exports.IDerivationState.POSSIBLY_STALE?d.dependenciesState=exports.IDerivationState.STALE:d.dependenciesState===exports.IDerivationState.UP_TO_DATE&&(observable$$1.lowestObserverState=exports.IDerivationState.UP_TO_DATE)}))}function propagateMaybeChanged$$1(observable$$1){observable$$1.lowestObserverState!==exports.IDerivationState.UP_TO_DATE||(observable$$1.lowestObserverState=exports.IDerivationState.POSSIBLY_STALE,observable$$1.observers.forEach(function(d){d.dependenciesState===exports.IDerivationState.UP_TO_DATE&&(d.dependenciesState=exports.IDerivationState.POSSIBLY_STALE,d.isTracing!==TraceMode$$1.NONE&&logTraceInfo(d,observable$$1),d.onBecomeStale())}))}function logTraceInfo(derivation,observable$$1){if(console.log("[mobx.trace] '"+derivation.name+"' is invalidated due to a change in: '"+observable$$1.name+"'"),derivation.isTracing===TraceMode$$1.BREAK){var lines=[];printDepTree(getDependencyTree$$1(derivation),lines,1),new Function("debugger;\n/*\nTracing '"+derivation.name+"'\n\nYou are entering this break point because derivation '"+derivation.name+"' is being traced and '"+observable$$1.name+"' is now forcing it to update.\nJust follow the stacktrace you should now see in the devtools to see precisely what piece of your code is causing this update\nThe stackframe you are looking for is at least ~6-8 stack-frames up.\n\n"+(derivation instanceof ComputedValue$$1?derivation.derivation.toString():"")+"\n\nThe dependencies for this derivation are:\n\n"+lines.join("\n")+"\n*/\n    ")()}}function printDepTree(tree,lines,depth){return 1e3<=lines.length?void lines.push("(and many more)"):void(lines.push(""+Array(depth).join("\t")+tree.name),tree.dependencies&&tree.dependencies.forEach(function(child){return printDepTree(child,lines,depth+1)}))}function runReactions$$1(){0<globalState$$1.inBatch||globalState$$1.isRunningReactions||reactionScheduler(runReactionsHelper)}function runReactionsHelper(){globalState$$1.isRunningReactions=!0;for(var allReactions=globalState$$1.pendingReactions,iterations=0;0<allReactions.length;){++iterations===100&&(console.error("Reaction doesn't converge to a stable state after 100 iterations."+(" Probably there is a cycle in the reactive function: "+allReactions[0])),allReactions.splice(0));for(var remainingReactions=allReactions.splice(0),i=0,l=remainingReactions.length;i<l;i++)remainingReactions[i].runReaction()}globalState$$1.isRunningReactions=!1}function setReactionScheduler$$1(fn){var baseScheduler=reactionScheduler;reactionScheduler=function(f){return fn(function(){return baseScheduler(f)})}}function isSpyEnabled$$1(){return"production"!==process.env.NODE_ENV&&!!globalState$$1.spyListeners.length}function spyReport$$1(event){if("production"!==process.env.NODE_ENV&&globalState$$1.spyListeners.length)for(var listeners=globalState$$1.spyListeners,i=0,l=listeners.length;void 0>i;i++)listeners[i](event)}function spyReportStart$$1(event){if("production"!==process.env.NODE_ENV){var change=__assign({},event,{spyReportStart:!0});spyReport$$1(change)}}function spyReportEnd$$1(change){"production"===process.env.NODE_ENV||(change?spyReport$$1(__assign({},change,{spyReportEnd:!0})):spyReport$$1(END_EVENT))}function spy$$1(listener){return"production"===process.env.NODE_ENV?(console.warn("[mobx.spy] Is a no-op in production builds"),function(){}):(globalState$$1.spyListeners.push(listener),once$$1(function(){globalState$$1.spyListeners=globalState$$1.spyListeners.filter(function(l){return l!==listener})}))}function dontReassignFields(){fail$1("production"!==process.env.NODE_ENV&&"@action fields are not reassignable")}function namedActionDecorator$$1(name){return function(target,prop,descriptor){if(descriptor){if("production"!==process.env.NODE_ENV&&descriptor.get!==void 0)return fail$1("@action cannot be used with getters");if(descriptor.value)return{value:createAction$$1(name,descriptor.value),enumerable:!1,configurable:!0,writable:!0};var initializer_1=descriptor.initializer;return{enumerable:!1,configurable:!0,writable:!0,initializer:function initializer(){return createAction$$1(name,initializer_1.call(this))}}}return actionFieldDecorator$$1(name).apply(this,arguments)}}function actionFieldDecorator$$1(name){return function(target,prop){Object.defineProperty(target,prop,{configurable:!0,enumerable:!1,get:function get(){},set:function set(value){addHiddenProp$$1(this,prop,action$$1(name,value))}})}}function isAction$$1(thing){return"function"==typeof thing&&!0===thing.isMobxAction}function defineBoundAction$$1(target,propertyName,fn){addHiddenProp$$1(target,propertyName,createAction$$1(propertyName,fn.bind(target)))}function autorun$$1(view,opts){function reactionRunner(){view(reaction$$1)}void 0===opts&&(opts=EMPTY_OBJECT$$1),"production"!==process.env.NODE_ENV&&(invariant$$1("function"==typeof view,"Autorun expects a function as first argument"),invariant$$1(!1===isAction$$1(view),"Autorun does not accept actions since actions are untrackable"));var reaction$$1,name=opts&&opts.name||view.name||"Autorun@"+getNextId$$1(),runSync=!opts.scheduler&&!opts.delay;if(runSync)reaction$$1=new Reaction$$1(name,function(){this.track(reactionRunner)},opts.onError);else{var scheduler_1=createSchedulerFromOptions(opts),isScheduled_1=!1;reaction$$1=new Reaction$$1(name,function(){isScheduled_1||(isScheduled_1=!0,scheduler_1(function(){isScheduled_1=!1,reaction$$1.isDisposed||reaction$$1.track(reactionRunner)}))},opts.onError)}return reaction$$1.schedule(),reaction$$1.getDisposer()}function createSchedulerFromOptions(opts){return opts.scheduler?opts.scheduler:opts.delay?function(f){return setTimeout(f,opts.delay)}:run}function wrapErrorHandler(errorHandler,baseFn){return function(){try{return baseFn.apply(this,arguments)}catch(e){errorHandler.call(this,e)}}}function onBecomeObserved$$1(thing,arg2,arg3){return interceptHook("onBecomeObserved",thing,arg2,arg3)}function onBecomeUnobserved$$1(thing,arg2,arg3){return interceptHook("onBecomeUnobserved",thing,arg2,arg3)}function interceptHook(hook,thing,arg2,arg3){var atom="string"==typeof arg2?getAtom$$1(thing,arg2):getAtom$$1(thing),cb="string"==typeof arg2?arg3:arg2,orig=atom[hook];return"function"==typeof orig?(atom[hook]=function(){orig.call(this),cb.call(this)},function(){atom[hook]=orig}):fail$1("production"!==process.env.NODE_ENV&&"Not an atom that can be (un)observed")}function configure$$1(options){var enforceActions=options.enforceActions,computedRequiresReaction=options.computedRequiresReaction,disableErrorBoundaries=options.disableErrorBoundaries,reactionScheduler=options.reactionScheduler;if(enforceActions!==void 0){if("boolean"!=typeof enforceActions&&"strict"!==enforceActions)return fail("Invalid configuration for 'enforceActions': "+enforceActions);globalState$$1.enforceActions=enforceActions,globalState$$1.allowStateChanges=!0!==enforceActions&&"strict"!==enforceActions}computedRequiresReaction!==void 0&&(globalState$$1.computedRequiresReaction=!!computedRequiresReaction),!0===options.isolateGlobalState&&isolateGlobalState$$1(),disableErrorBoundaries!==void 0&&(!0===disableErrorBoundaries&&console.warn("WARNING: Debug feature only. MobX will NOT recover from errors when `disableErrorBoundaries` is enabled."),globalState$$1.disableErrorBoundaries=!!disableErrorBoundaries),reactionScheduler&&setReactionScheduler$$1(reactionScheduler)}function extendObservable$$1(target,properties,decorators,options){"production"!==process.env.NODE_ENV&&(invariant$$1(2<=arguments.length&&4>=arguments.length,"'extendObservable' expected 2-4 arguments"),invariant$$1("object"===("undefined"==typeof target?"undefined":_typeof(target)),"'extendObservable' expects an object as first argument"),invariant$$1(!isObservableMap$$1(target),"'extendObservable' should not be used on maps, use map.merge instead")),options=asCreateObservableOptions$$1(options);var defaultDecorator=getDefaultDecoratorFromObjectOptions$$1(options);return asObservableObject$$1(target,options.name,defaultDecorator.enhancer),properties&&extendObservableObjectWithProperties$$1(target,properties,decorators,defaultDecorator),target}function getDefaultDecoratorFromObjectOptions$$1(options){return options.defaultDecorator||(!1===options.deep?refDecorator$$1:deepDecorator$$1)}function extendObservableObjectWithProperties$$1(target,properties,decorators,defaultDecorator){if("production"!==process.env.NODE_ENV&&(invariant$$1(!isObservable$$1(properties),"Extending an object with another observable (object) is not supported. Please construct an explicit propertymap, using `toJS` if need. See issue #540"),decorators))for(var key in decorators)key in properties||fail$1("Trying to declare a decorator for unspecified property '"+key+"'");startBatch$$1();try{for(var key in properties){var descriptor=Object.getOwnPropertyDescriptor(properties,key);"production"!==process.env.NODE_ENV&&(Object.getOwnPropertyDescriptor(target,key)&&fail$1("'extendObservable' can only be used to introduce new properties. Use 'set' or 'decorate' instead. The property '"+key+"' already exists on '"+target+"'"),isComputed$$1(descriptor.value)&&fail$1("Passing a 'computed' as initial property value is no longer supported by extendObservable. Use a getter or decorator instead"));var decorator=decorators&&key in decorators?decorators[key]:descriptor.get?computedDecorator$$1:defaultDecorator;"production"!==process.env.NODE_ENV&&"function"!=typeof decorator&&fail$1("Not a valid decorator for '"+key+"', got: "+decorator);var resultDescriptor=decorator(target,key,descriptor,!0);resultDescriptor&&Object.defineProperty(target,key,resultDescriptor)}}finally{endBatch$$1()}}function getDependencyTree$$1(thing,property){return nodeToDependencyTree(getAtom$$1(thing,property))}function nodeToDependencyTree(node){var result={name:node.name};return node.observing&&0<node.observing.length&&(result.dependencies=unique$$1(node.observing).map(nodeToDependencyTree)),result}function nodeToObserverTree(node){var result={name:node.name};return hasObservers$$1(node)&&(result.observers=Array.from(getObservers$$1(node)).map(nodeToObserverTree)),result}function cancelPromise(promise){"function"==typeof promise.cancel&&promise.cancel()}function interceptInterceptable(thing,handler){return getAdministration$$1(thing).intercept(handler)}function interceptProperty(thing,property,handler){return getAdministration$$1(thing,property).intercept(handler)}function _isComputed$$1(value,property){if(null===value||value===void 0)return!1;if(void 0!==property){if(!1===isObservableObject$$1(value))return!1;if(!value[$mobx$$1].values.has(property))return!1;var atom=getAtom$$1(value,property);return isComputedValue$$1(atom)}return isComputedValue$$1(value)}function isComputed$$1(value){return 1<arguments.length?fail$1("production"!==process.env.NODE_ENV&&"isComputed expects only 1 argument. Use isObservableProp to inspect the observability of a property"):_isComputed$$1(value)}function _isObservable(value,property){return null!==value&&void 0!==value&&(void 0===property?isObservableObject$$1(value)||!!value[$mobx$$1]||isAtom$$1(value)||isReaction$$1(value)||isComputedValue$$1(value):"production"!==process.env.NODE_ENV&&(isObservableMap$$1(value)||isObservableArray$$1(value))?fail$1("isObservable(object, propertyName) is not supported for arrays and maps. Use map.has or array.length instead."):!!isObservableObject$$1(value)&&value[$mobx$$1].values.has(property))}function isObservable$$1(value){return 1!==arguments.length&&fail$1("production"!==process.env.NODE_ENV&&"isObservable expects only 1 argument. Use isObservableProp to inspect the observability of a property"),_isObservable(value)}function keys$$1(obj){return isObservableObject$$1(obj)?obj[$mobx$$1].getKeys():isObservableMap$$1(obj)?Array.from(obj.keys()):fail$1("production"!==process.env.NODE_ENV&&"'keys()' can only be used on observable objects and maps")}function set$$1(obj,key,value){if(2===arguments.length){startBatch$$1();var values_1=key;try{for(var key_1 in values_1)set$$1(obj,key_1,values_1[key_1])}finally{endBatch$$1()}return}if(isObservableObject$$1(obj)){var adm=obj[$mobx$$1],existingObservable=adm.values.get(key);existingObservable?adm.write(key,value):adm.addObservableProp(key,value,adm.defaultEnhancer)}else if(isObservableMap$$1(obj))obj.set(key,value);else if(isObservableArray$$1(obj))"number"!=typeof key&&(key=parseInt(key,10)),invariant$$1(0<=key,"Not a valid index: '"+key+"'"),startBatch$$1(),key>=obj.length&&(obj.length=key+1),obj[key]=value,endBatch$$1();else return fail$1("production"!==process.env.NODE_ENV&&"'set()' can only be used on observable objects, arrays and maps")}function has$$1(obj,key){if(isObservableObject$$1(obj)){var adm=getAdministration$$1(obj);return adm.has(key)}return isObservableMap$$1(obj)?obj.has(key):isObservableArray$$1(obj)?0<=key&&key<obj.length:fail$1("production"!==process.env.NODE_ENV&&"'has()' can only be used on observable objects, arrays and maps")}function observeObservable(thing,listener,fireImmediately){return getAdministration$$1(thing).observe(listener,fireImmediately)}function observeObservableProperty(thing,property,listener,fireImmediately){return getAdministration$$1(thing,property).observe(listener,fireImmediately)}function cache(map,key,value,options){return options.detectCycles&&map.set(key,value),value}function toJSHelper(source,options,__alreadySeen){if(!isObservable$$1(source))return source;var detectCycles=!0===options.detectCycles;if(detectCycles&&null!==source&&"object"===("undefined"==typeof source?"undefined":_typeof(source))&&__alreadySeen.has(source))return __alreadySeen.get(source);if(isObservableArray$$1(source)){var res=cache(__alreadySeen,source,[],options),toAdd=source.map(function(value){return toJSHelper(value,options,__alreadySeen)});res.length=toAdd.length;for(var i=0,l=toAdd.length;i<l;i++)res[i]=toAdd[i];return res}if(isObservableObject$$1(source)){var res=cache(__alreadySeen,source,{},options);for(var key in keys$$1(source),source)res[key]=toJSHelper(source[key],options,__alreadySeen);return res}if(isObservableMap$$1(source)){if(!1===options.exportMapsAsObjects){var res_1=cache(__alreadySeen,source,new Map,options);return source.forEach(function(value,key){res_1.set(key,toJSHelper(value,options,__alreadySeen))}),res_1}var res_2=cache(__alreadySeen,source,{},options);return source.forEach(function(value,key){res_2[key]=toJSHelper(value,options,__alreadySeen)}),res_2}return isObservableValue$$1(source)?toJSHelper(source.get(),options,__alreadySeen):source}function trace$$1(){for(var args=[],_i=0;_i<arguments.length;_i++)args[_i]=arguments[_i];var enterBreakPoint=!1;"boolean"==typeof args[args.length-1]&&(enterBreakPoint=args.pop());var derivation=getAtomFromArgs(args);return derivation?void(derivation.isTracing===TraceMode$$1.NONE&&console.log("[mobx.trace] '"+derivation.name+"' tracing enabled"),derivation.isTracing=enterBreakPoint?TraceMode$$1.BREAK:TraceMode$$1.LOG):fail$1("production"!==process.env.NODE_ENV&&"'trace(break?)' can only be used inside a tracked computed value or a Reaction. Consider passing in the computed value or reaction explicitly")}function getAtomFromArgs(args){switch(args.length){case 0:return globalState$$1.trackingDerivation;case 1:return getAtom$$1(args[0]);case 2:return getAtom$$1(args[0],args[1]);}}function transaction$$1(action$$1,thisArg){void 0===thisArg&&(thisArg=void 0),startBatch$$1();try{return action$$1.apply(thisArg)}finally{endBatch$$1()}}function _when(predicate,effect,opts){var timeoutHandle;"number"==typeof opts.timeout&&(timeoutHandle=setTimeout(function(){if(!disposer[$mobx$$1].isDisposed){disposer();var error=new Error("WHEN_TIMEOUT");if(opts.onError)opts.onError(error);else throw error}},opts.timeout)),opts.name=opts.name||"When@"+getNextId$$1();var effectAction=createAction$$1(opts.name+"-effect",effect),disposer=autorun$$1(function(r){predicate()&&(r.dispose(),timeoutHandle&&clearTimeout(timeoutHandle),effectAction())},opts);return disposer}function whenPromise(predicate,opts){if("production"!==process.env.NODE_ENV&&opts&&opts.onError)return fail$1("the options 'onError' and 'promise' cannot be combined");var cancel,res=new Promise(function(resolve,reject){var disposer=_when(predicate,resolve,__assign({},opts,{onError:reject}));cancel=function(){disposer(),reject("WHEN_CANCELLED")}});return res.cancel=cancel,res}function getAdm(target){return target[$mobx$$1]}function createDynamicObservableObject$$1(base){var proxy=new Proxy(base,objectProxyTraps);return base[$mobx$$1].proxy=proxy,proxy}function hasInterceptors$$1(interceptable){return interceptable.interceptors!==void 0&&0<interceptable.interceptors.length}function registerInterceptor$$1(interceptable,handler){var interceptors=interceptable.interceptors||(interceptable.interceptors=[]);return interceptors.push(handler),once$$1(function(){var idx=interceptors.indexOf(handler);-1!==idx&&interceptors.splice(idx,1)})}function interceptChange$$1(interceptable,change){var prevU=untrackedStart$$1();try{var interceptors=interceptable.interceptors;if(interceptors)for(var i=0,l=interceptors.length;i<l&&(change=interceptors[i](change),invariant$$1(!change||change.type,"Intercept handlers should return nothing or a change object"),!!change);i++);return change}finally{untrackedEnd$$1(prevU)}}function hasListeners$$1(listenable){return listenable.changeListeners!==void 0&&0<listenable.changeListeners.length}function registerListener$$1(listenable,handler){var listeners=listenable.changeListeners||(listenable.changeListeners=[]);return listeners.push(handler),once$$1(function(){var idx=listeners.indexOf(handler);-1!==idx&&listeners.splice(idx,1)})}function notifyListeners$$1(listenable,change){var prevU=untrackedStart$$1(),listeners=listenable.changeListeners;if(listeners){listeners=listeners.slice();for(var i=0,l=listeners.length;i<l;i++)listeners[i](change);untrackedEnd$$1(prevU)}}function createObservableArray$$1(initialValues,enhancer,name,owned){void 0===name&&(name="ObservableArray@"+getNextId$$1()),void 0===owned&&(owned=!1);var adm=new ObservableArrayAdministration(name,enhancer,owned);addHiddenFinalProp$$1(adm.values,$mobx$$1,adm);var proxy=new Proxy(adm.values,arrayTraps);if(adm.proxy=proxy,initialValues&&initialValues.length){var prev=allowStateChangesStart$$1(!0);adm.spliceWithArray(0,0,initialValues),allowStateChangesEnd$$1(prev)}return proxy}function isObservableArray$$1(thing){return isObject$$1(thing)&&isObservableArrayAdministration(thing[$mobx$$1])}function asObservableObject$$1(target,name,defaultEnhancer){if(void 0===name&&(name=""),void 0===defaultEnhancer&&(defaultEnhancer=deepEnhancer$$1),Object.prototype.hasOwnProperty.call(target,$mobx$$1))return target[$mobx$$1];"production"!==process.env.NODE_ENV&&invariant$$1(Object.isExtensible(target),"Cannot make the designated object observable; it is not extensible"),isPlainObject$$1(target)||(name=(target.constructor.name||"ObservableObject")+"@"+getNextId$$1()),name||(name="ObservableObject@"+getNextId$$1());var adm=new ObservableObjectAdministration$$1(target,new Map(),name,defaultEnhancer);return addHiddenProp$$1(target,$mobx$$1,adm),adm}function generateObservablePropConfig$$1(propName){return observablePropertyConfigs[propName]||(observablePropertyConfigs[propName]={configurable:!0,enumerable:!0,get:function get(){return this[$mobx$$1].read(propName)},set:function set(v){this[$mobx$$1].write(propName,v)}})}function getAdministrationForComputedPropOwner(owner){var adm=owner[$mobx$$1];return adm?adm:(initializeInstance$$1(owner),owner[$mobx$$1])}function generateComputedPropConfig$$1(propName){return computedPropertyConfigs[propName]||(computedPropertyConfigs[propName]={configurable:!0,enumerable:!1,get:function get(){return getAdministrationForComputedPropOwner(this).read(propName)},set:function set(v){getAdministrationForComputedPropOwner(this).write(propName,v)}})}function isObservableObject$$1(thing){return!!isObject$$1(thing)&&(initializeInstance$$1(thing),isObservableObjectAdministration(thing[$mobx$$1]))}function getAtom$$1(thing,property){if("object"===("undefined"==typeof thing?"undefined":_typeof(thing))&&null!==thing){if(isObservableArray$$1(thing))return void 0!==property&&fail$1("production"!==process.env.NODE_ENV&&"It is not possible to get index atoms from arrays"),thing[$mobx$$1].atom;if(isObservableMap$$1(thing)){var anyThing=thing;if(void 0===property)return anyThing._keysAtom;var observable$$1=anyThing._data.get(property)||anyThing._hasMap.get(property);return observable$$1||fail$1("production"!==process.env.NODE_ENV&&"the entry '"+property+"' does not exist in the observable map '"+getDebugName$$1(thing)+"'"),observable$$1}if(initializeInstance$$1(thing),property&&!thing[$mobx$$1]&&thing[property],isObservableObject$$1(thing)){if(!property)return fail$1("production"!==process.env.NODE_ENV&&"please specify a property");var observable$$1=thing[$mobx$$1].values.get(property);return observable$$1||fail$1("production"!==process.env.NODE_ENV&&"no observable property '"+property+"' found on the observable object '"+getDebugName$$1(thing)+"'"),observable$$1}if(isAtom$$1(thing)||isComputedValue$$1(thing)||isReaction$$1(thing))return thing}else if("function"==typeof thing&&isReaction$$1(thing[$mobx$$1]))return thing[$mobx$$1];return fail$1("production"!==process.env.NODE_ENV&&"Cannot obtain atom from "+thing)}function getAdministration$$1(thing,property){return(thing||fail$1("Expecting some object"),void 0!==property)?getAdministration$$1(getAtom$$1(thing,property)):isAtom$$1(thing)||isComputedValue$$1(thing)||isReaction$$1(thing)?thing:isObservableMap$$1(thing)?thing:(initializeInstance$$1(thing),thing[$mobx$$1]?thing[$mobx$$1]:void fail$1("production"!==process.env.NODE_ENV&&"Cannot obtain administration from "+thing))}function getDebugName$$1(thing,property){var named;return named=void 0===property?isObservableObject$$1(thing)||isObservableMap$$1(thing)?getAdministration$$1(thing):getAtom$$1(thing):getAtom$$1(thing,property),named.name}function deepEqual$$1(a,b){return eq(a,b)}function eq(a,b,aStack,bStack){if(a===b)return 0!==a||1/a==1/b;if(null==a||null==b)return!1;if(a!==a)return b!==b;var type="undefined"==typeof a?"undefined":_typeof(a);return("function"===type||"object"===type||"object"==("undefined"==typeof b?"undefined":_typeof(b)))&&deepEq(a,b,aStack,bStack)}function deepEq(a,b,aStack,bStack){a=unwrap(a),b=unwrap(b);var className=toString.call(a);if(className!==toString.call(b))return!1;switch(className){case"[object RegExp]":case"[object String]":return""+a==""+b;case"[object Number]":return+a==+a?0==+a?1/+a==1/b:+a==+b:+b!=+b;case"[object Date]":case"[object Boolean]":return+a==+b;case"[object Symbol]":return"undefined"!=typeof Symbol&&Symbol.valueOf.call(a)===Symbol.valueOf.call(b);}var areArrays="[object Array]"===className;if(!areArrays){if("object"!=("undefined"==typeof a?"undefined":_typeof(a))||"object"!=("undefined"==typeof b?"undefined":_typeof(b)))return!1;var aCtor=a.constructor,bCtor=b.constructor;if(aCtor!==bCtor&&!("function"==typeof aCtor&&aCtor instanceof aCtor&&"function"==typeof bCtor&&bCtor instanceof bCtor)&&"constructor"in a&&"constructor"in b)return!1}aStack=aStack||[],bStack=bStack||[];for(var length=aStack.length;length--;)if(aStack[length]===a)return bStack[length]===b;if(aStack.push(a),bStack.push(b),areArrays){if(length=a.length,length!==b.length)return!1;for(;length--;)if(!eq(a[length],b[length],aStack,bStack))return!1}else{var key,keys$$1=Object.keys(a);if(length=keys$$1.length,Object.keys(b).length!==length)return!1;for(;length--;)if(key=keys$$1[length],!(has$1(b,key)&&eq(a[key],b[key],aStack,bStack)))return!1}return aStack.pop(),bStack.pop(),!0}function unwrap(a){return isObservableArray$$1(a)?a.slice():isES6Map$$1(a)||isObservableMap$$1(a)?Array.from(a.entries()):a}function has$1(a,key){return Object.prototype.hasOwnProperty.call(a,key)}function makeIterable(iterator){return iterator[Symbol.iterator]=self,iterator}function self(){return this}var _Mathmax=Math.max;Object.defineProperty(exports,"__esModule",{value:!0});var extendStatics=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(d,b){d.__proto__=b}||function(d,b){for(var p in b)b.hasOwnProperty(p)&&(d[p]=b[p])},__assign=Object.assign||function(t){for(var s,i=1,n=arguments.length;i<n;i++)for(var p in s=arguments[i],s)Object.prototype.hasOwnProperty.call(s,p)&&(t[p]=s[p]);return t},EMPTY_ARRAY$$1=[];Object.freeze(EMPTY_ARRAY$$1);var EMPTY_OBJECT$$1={};Object.freeze(EMPTY_OBJECT$$1);var noop$$1=function(){},$mobx$$1=Symbol("mobx administration"),Atom$$1=function(){function Atom$$1(name){void 0===name&&(name="Atom@"+getNextId$$1()),this.name=name,this.isPendingUnobservation=!1,this.isBeingObserved=!1,this.observers=new Set,this.diffValue=0,this.lastAccessedBy=0,this.lowestObserverState=exports.IDerivationState.NOT_TRACKING}return Atom$$1.prototype.onBecomeUnobserved=function(){},Atom$$1.prototype.onBecomeObserved=function(){},Atom$$1.prototype.reportObserved=function(){return reportObserved$$1(this)},Atom$$1.prototype.reportChanged=function(){startBatch$$1(),propagateChanged$$1(this),endBatch$$1()},Atom$$1.prototype.toString=function(){return this.name},Atom$$1}(),isAtom$$1=createInstanceofPredicate$$1("Atom",Atom$$1),comparer$$1={identity:function(a,b){return a===b},structural:function(a,b){return deepEqual$$1(a,b)},default:function(a,b){return Object.is(a,b)}},mobxDidRunLazyInitializersSymbol$$1=Symbol("mobx did run lazy initializers"),mobxPendingDecorators$$1=Symbol("mobx pending decorators"),enumerableDescriptorCache={},nonEnumerableDescriptorCache={},defaultCreateObservableOptions$$1={deep:!0,name:void 0,defaultDecorator:void 0,proxy:!0};Object.freeze(defaultCreateObservableOptions$$1);var deepDecorator$$1=createDecoratorForEnhancer$$1(deepEnhancer$$1),shallowDecorator=createDecoratorForEnhancer$$1(function(v,_,name){return void 0===v||null===v?v:isObservableObject$$1(v)||isObservableArray$$1(v)||isObservableMap$$1(v)?v:Array.isArray(v)?observable$$1.array(v,{name:name,deep:!1}):isPlainObject$$1(v)?observable$$1.object(v,void 0,{name:name,deep:!1}):isES6Map$$1(v)?observable$$1.map(v,{name:name,deep:!1}):fail$1("production"!==process.env.NODE_ENV&&"The shallow modifier / decorator can only used in combination with arrays, objects and maps")}),refDecorator$$1=createDecoratorForEnhancer$$1(referenceEnhancer$$1),refStructDecorator=createDecoratorForEnhancer$$1(function(v,oldValue){if("production"!==process.env.NODE_ENV&&isObservable$$1(v))throw"observable.struct should not be used with observable values";return deepEqual$$1(v,oldValue)?oldValue:v}),observableFactories={box:function box(value,options){2<arguments.length&&incorrectlyUsedAsDecorator("box");var o=asCreateObservableOptions$$1(options);return new ObservableValue$$1(value,getEnhancerFromOptions(o),o.name)},array:function array(initialValues,options){2<arguments.length&&incorrectlyUsedAsDecorator("array");var o=asCreateObservableOptions$$1(options);return createObservableArray$$1(initialValues,getEnhancerFromOptions(o),o.name)},map:function map(initialValues,options){2<arguments.length&&incorrectlyUsedAsDecorator("map");var o=asCreateObservableOptions$$1(options);return new ObservableMap$$1(initialValues,getEnhancerFromOptions(o),o.name)},object:function object(props,decorators,options){"string"==typeof arguments[1]&&incorrectlyUsedAsDecorator("object");var o=asCreateObservableOptions$$1(options);if(!1===o.proxy)return extendObservable$$1({},props,decorators,o);var defaultDecorator=getDefaultDecoratorFromObjectOptions$$1(o),base=extendObservable$$1({},void 0,void 0,o),proxy=createDynamicObservableObject$$1(base);return extendObservableObjectWithProperties$$1(proxy,props,decorators,defaultDecorator),proxy},ref:refDecorator$$1,shallow:shallowDecorator,deep:deepDecorator$$1,struct:refStructDecorator},observable$$1=function(v,arg2,arg3){if("string"==typeof arguments[1])return deepDecorator$$1.apply(null,arguments);if(isObservable$$1(v))return v;var res=isPlainObject$$1(v)?observable$$1.object(v,arg2,arg3):Array.isArray(v)?observable$$1.array(v,arg2):isES6Map$$1(v)?observable$$1.map(v,arg2):v;return res===v?void fail$1("production"!==process.env.NODE_ENV&&"The provided value could not be converted into an observable. If you want just create an observable reference to the object use 'observable.box(value)'"):res};Object.keys(observableFactories).forEach(function(name){return observable$$1[name]=observableFactories[name]});var computedDecorator$$1=createPropDecorator$$1(!1,function(instance,propertyName,descriptor,decoratorTarget,decoratorArgs){var get$$1=descriptor.get,set$$1=descriptor.set,options=decoratorArgs[0]||{};asObservableObject$$1(instance).addComputedProp(decoratorTarget,propertyName,__assign({get:get$$1,set:set$$1,context:instance},options))}),computedStructDecorator=computedDecorator$$1({equals:comparer$$1.structural}),computed$$1=function(arg1,arg2){if("string"==typeof arg2)return computedDecorator$$1.apply(null,arguments);if(null!==arg1&&"object"===("undefined"==typeof arg1?"undefined":_typeof(arg1))&&1===arguments.length)return computedDecorator$$1.apply(null,arguments);"production"!==process.env.NODE_ENV&&(invariant$$1("function"==typeof arg1,"First argument to `computed` should be an expression."),invariant$$1(3>arguments.length,"Computed takes one or two arguments if used as function"));var opts="object"===("undefined"==typeof arg2?"undefined":_typeof(arg2))?arg2:{};return opts.get=arg1,opts.set="function"==typeof arg2?arg2:opts.set,opts.name=opts.name||arg1.name||"",new ComputedValue$$1(opts)};computed$$1.struct=computedStructDecorator;var UNCHANGED$$1={},ObservableValue$$1=function(_super){function ObservableValue$$1(value,enhancer,name,notifySpy){void 0===name&&(name="ObservableValue@"+getNextId$$1()),void 0===notifySpy&&(notifySpy=!0);var _this=_super.call(this,name)||this;return _this.enhancer=enhancer,_this.hasUnreportedChange=!1,_this.value=enhancer(value,void 0,name),notifySpy&&isSpyEnabled$$1()&&"production"!==process.env.NODE_ENV&&spyReport$$1({type:"create",name:_this.name,newValue:""+_this.value}),_this}return __extends(ObservableValue$$1,_super),ObservableValue$$1.prototype.dehanceValue=function(value){return void 0===this.dehancer?value:this.dehancer(value)},ObservableValue$$1.prototype.set=function(newValue){var oldValue=this.value;if(newValue=this.prepareNewValue(newValue),newValue!==UNCHANGED$$1){var notifySpy=isSpyEnabled$$1();notifySpy&&"production"!==process.env.NODE_ENV&&spyReportStart$$1({type:"update",name:this.name,newValue:newValue,oldValue:oldValue}),this.setNewValue(newValue),notifySpy&&"production"!==process.env.NODE_ENV&&spyReportEnd$$1()}},ObservableValue$$1.prototype.prepareNewValue=function(newValue){if(checkIfStateModificationsAreAllowed$$1(this),hasInterceptors$$1(this)){var change=interceptChange$$1(this,{object:this,type:"update",newValue:newValue});if(!change)return UNCHANGED$$1;newValue=change.newValue}return newValue=this.enhancer(newValue,this.value,this.name),this.value===newValue?UNCHANGED$$1:newValue},ObservableValue$$1.prototype.setNewValue=function(newValue){var oldValue=this.value;this.value=newValue,this.reportChanged(),hasListeners$$1(this)&&notifyListeners$$1(this,{type:"update",object:this,newValue:newValue,oldValue:oldValue})},ObservableValue$$1.prototype.get=function(){return this.reportObserved(),this.dehanceValue(this.value)},ObservableValue$$1.prototype.intercept=function(handler){return registerInterceptor$$1(this,handler)},ObservableValue$$1.prototype.observe=function(listener,fireImmediately){return fireImmediately&&listener({object:this,type:"update",newValue:this.value,oldValue:void 0}),registerListener$$1(this,listener)},ObservableValue$$1.prototype.toJSON=function(){return this.get()},ObservableValue$$1.prototype.toString=function(){return this.name+"["+this.value+"]"},ObservableValue$$1.prototype.valueOf=function(){return toPrimitive$$1(this.get())},ObservableValue$$1.prototype[Symbol.toPrimitive]=function(){return this.valueOf()},ObservableValue$$1}(Atom$$1),isObservableValue$$1=createInstanceofPredicate$$1("ObservableValue",ObservableValue$$1),ComputedValue$$1=function(){function ComputedValue$$1(options){if(this.dependenciesState=exports.IDerivationState.NOT_TRACKING,this.observing=[],this.newObserving=null,this.isBeingObserved=!1,this.isPendingUnobservation=!1,this.observers=new Set,this.diffValue=0,this.runId=0,this.lastAccessedBy=0,this.lowestObserverState=exports.IDerivationState.UP_TO_DATE,this.unboundDepsCount=0,this.__mapid="#"+getNextId$$1(),this.value=new CaughtException$$1(null),this.isComputing=!1,this.isRunningSetter=!1,this.isTracing=TraceMode$$1.NONE,this.firstGet=!0,"production"!==process.env.NODE_ENV&&!options.get)throw"[mobx] missing option for computed: get";this.derivation=options.get,this.name=options.name||"ComputedValue@"+getNextId$$1(),options.set&&(this.setter=createAction$$1(this.name+"-setter",options.set)),this.equals=options.equals||(options.compareStructural||options.struct?comparer$$1.structural:comparer$$1.default),this.scope=options.context,this.requiresReaction=!!options.requiresReaction,this.keepAlive=!!options.keepAlive}return ComputedValue$$1.prototype.onBecomeStale=function(){propagateMaybeChanged$$1(this)},ComputedValue$$1.prototype.onBecomeUnobserved=function(){},ComputedValue$$1.prototype.onBecomeObserved=function(){},ComputedValue$$1.prototype.get=function(){var _this=this;this.keepAlive&&this.firstGet&&(this.firstGet=!1,autorun$$1(function(){return _this.get()})),this.isComputing&&fail$1("Cycle detected in computation "+this.name+": "+this.derivation),0===globalState$$1.inBatch&&0===this.observers.size?shouldCompute$$1(this)&&(this.warnAboutUntrackedRead(),startBatch$$1(),this.value=this.computeValue(!1),endBatch$$1()):(reportObserved$$1(this),shouldCompute$$1(this)&&this.trackAndCompute()&&propagateChangeConfirmed$$1(this));var result=this.value;if(isCaughtException$$1(result))throw result.cause;return result},ComputedValue$$1.prototype.peek=function(){var res=this.computeValue(!1);if(isCaughtException$$1(res))throw res.cause;return res},ComputedValue$$1.prototype.set=function(value){if(this.setter){invariant$$1(!this.isRunningSetter,"The setter of computed value '"+this.name+"' is trying to update itself. Did you intend to update an _observable_ value, instead of the computed property?"),this.isRunningSetter=!0;try{this.setter.call(this.scope,value)}finally{this.isRunningSetter=!1}}else invariant$$1(!1,"production"!==process.env.NODE_ENV&&"[ComputedValue '"+this.name+"'] It is not possible to assign a new value to a computed value.")},ComputedValue$$1.prototype.trackAndCompute=function(){isSpyEnabled$$1()&&"production"!==process.env.NODE_ENV&&spyReport$$1({object:this.scope,type:"compute",name:this.name});var oldValue=this.value,wasSuspended=this.dependenciesState===exports.IDerivationState.NOT_TRACKING,newValue=this.computeValue(!0),changed=wasSuspended||isCaughtException$$1(oldValue)||isCaughtException$$1(newValue)||!this.equals(oldValue,newValue);return changed&&(this.value=newValue),changed},ComputedValue$$1.prototype.computeValue=function(track){this.isComputing=!0,globalState$$1.computationDepth++;var res;if(track)res=trackDerivedFunction$$1(this,this.derivation,this.scope);else if(!0===globalState$$1.disableErrorBoundaries)res=this.derivation.call(this.scope);else try{res=this.derivation.call(this.scope)}catch(e){res=new CaughtException$$1(e)}return globalState$$1.computationDepth--,this.isComputing=!1,res},ComputedValue$$1.prototype.suspend=function(){clearObserving$$1(this),this.value=void 0},ComputedValue$$1.prototype.observe=function(listener,fireImmediately){var _this=this,firstTime=!0,prevValue=void 0;return autorun$$1(function(){var newValue=_this.get();if(!firstTime||fireImmediately){var prevU=untrackedStart$$1();listener({type:"update",object:_this,newValue:newValue,oldValue:prevValue}),untrackedEnd$$1(prevU)}firstTime=!1,prevValue=newValue})},ComputedValue$$1.prototype.warnAboutUntrackedRead=function(){"production"===process.env.NODE_ENV||(!0===this.requiresReaction&&fail$1("[mobx] Computed value "+this.name+" is read outside a reactive context"),this.isTracing!==TraceMode$$1.NONE&&console.log("[mobx.trace] '"+this.name+"' is being read outside a reactive context. Doing a full recompute"),globalState$$1.computedRequiresReaction&&console.warn("[mobx] Computed value "+this.name+" is being read outside a reactive context. Doing a full recompute"))},ComputedValue$$1.prototype.toJSON=function(){return this.get()},ComputedValue$$1.prototype.toString=function(){return this.name+"["+this.derivation.toString()+"]"},ComputedValue$$1.prototype.valueOf=function(){return toPrimitive$$1(this.get())},ComputedValue$$1.prototype[Symbol.toPrimitive]=function(){return this.valueOf()},ComputedValue$$1}(),isComputedValue$$1=createInstanceofPredicate$$1("ComputedValue",ComputedValue$$1);(function(IDerivationState$$1){IDerivationState$$1[IDerivationState$$1.NOT_TRACKING=-1]="NOT_TRACKING",IDerivationState$$1[IDerivationState$$1.UP_TO_DATE=0]="UP_TO_DATE",IDerivationState$$1[IDerivationState$$1.POSSIBLY_STALE=1]="POSSIBLY_STALE",IDerivationState$$1[IDerivationState$$1.STALE=2]="STALE"})(exports.IDerivationState||(exports.IDerivationState={}));var TraceMode$$1;(function(TraceMode$$1){TraceMode$$1[TraceMode$$1.NONE=0]="NONE",TraceMode$$1[TraceMode$$1.LOG=1]="LOG",TraceMode$$1[TraceMode$$1.BREAK=2]="BREAK"})(TraceMode$$1||(TraceMode$$1={}));var CaughtException$$1=function(){return function(cause){this.cause=cause}}(),persistentKeys=["mobxGuid","spyListeners","enforceActions","computedRequiresReaction","disableErrorBoundaries","runId"],MobXGlobals$$1=function(){return function(){this.version=5,this.trackingDerivation=null,this.computationDepth=0,this.runId=0,this.mobxGuid=0,this.inBatch=0,this.pendingUnobservations=[],this.pendingReactions=[],this.isRunningReactions=!1,this.allowStateChanges=!0,this.enforceActions=!1,this.spyListeners=[],this.globalReactionErrorHandlers=[],this.computedRequiresReaction=!1,this.disableErrorBoundaries=!1}}(),globalState$$1=new MobXGlobals$$1,runInIsolationCalled=!1;{var global_1=getGlobal$$1();global_1.__mobxInstanceCount?(global_1.__mobxInstanceCount++,setTimeout(function(){runInIsolationCalled||fail$1("production"!==process.env.NODE_ENV&&"There are multiple mobx instances active. This might lead to unexpected results. See https://github.com/mobxjs/mobx/issues/1082 for details.")},1)):global_1.__mobxInstanceCount=1}var Reaction$$1=function(){function Reaction$$1(name,onInvalidate,errorHandler){void 0===name&&(name="Reaction@"+getNextId$$1()),this.name=name,this.onInvalidate=onInvalidate,this.errorHandler=errorHandler,this.observing=[],this.newObserving=[],this.dependenciesState=exports.IDerivationState.NOT_TRACKING,this.diffValue=0,this.runId=0,this.unboundDepsCount=0,this.__mapid="#"+getNextId$$1(),this.isDisposed=!1,this._isScheduled=!1,this._isTrackPending=!1,this._isRunning=!1,this.isTracing=TraceMode$$1.NONE}return Reaction$$1.prototype.onBecomeStale=function(){this.schedule()},Reaction$$1.prototype.schedule=function(){this._isScheduled||(this._isScheduled=!0,globalState$$1.pendingReactions.push(this),runReactions$$1())},Reaction$$1.prototype.isScheduled=function(){return this._isScheduled},Reaction$$1.prototype.runReaction=function(){if(!this.isDisposed){if(startBatch$$1(),this._isScheduled=!1,shouldCompute$$1(this)){this._isTrackPending=!0;try{this.onInvalidate(),this._isTrackPending&&isSpyEnabled$$1()&&"production"!==process.env.NODE_ENV&&spyReport$$1({name:this.name,type:"scheduled-reaction"})}catch(e){this.reportExceptionInDerivation(e)}}endBatch$$1()}},Reaction$$1.prototype.track=function(fn){startBatch$$1();var startTime,notify=isSpyEnabled$$1();notify&&"production"!==process.env.NODE_ENV&&(startTime=Date.now(),spyReportStart$$1({name:this.name,type:"reaction"})),this._isRunning=!0;var result=trackDerivedFunction$$1(this,fn,void 0);this._isRunning=!1,this._isTrackPending=!1,this.isDisposed&&clearObserving$$1(this),isCaughtException$$1(result)&&this.reportExceptionInDerivation(result.cause),notify&&"production"!==process.env.NODE_ENV&&spyReportEnd$$1({time:Date.now()-startTime}),endBatch$$1()},Reaction$$1.prototype.reportExceptionInDerivation=function(error){var _this=this;if(this.errorHandler)return void this.errorHandler(error,this);if(globalState$$1.disableErrorBoundaries)throw error;var message="[mobx] Encountered an uncaught exception that was thrown by a reaction or observer component, in: '"+this;console.error(message,error),isSpyEnabled$$1()&&spyReport$$1({type:"error",name:this.name,message:message,error:""+error}),globalState$$1.globalReactionErrorHandlers.forEach(function(f){return f(error,_this)})},Reaction$$1.prototype.dispose=function(){this.isDisposed||(this.isDisposed=!0,!this._isRunning&&(startBatch$$1(),clearObserving$$1(this),endBatch$$1()))},Reaction$$1.prototype.getDisposer=function(){var r=this.dispose.bind(this);return r[$mobx$$1]=this,r},Reaction$$1.prototype.toString=function(){return"Reaction["+this.name+"]"},Reaction$$1.prototype.trace=function(enterBreakPoint){void 0===enterBreakPoint&&(enterBreakPoint=!1),trace$$1(this,enterBreakPoint)},Reaction$$1}(),reactionScheduler=function(f){return f()},isReaction$$1=createInstanceofPredicate$$1("Reaction",Reaction$$1),END_EVENT={spyReportEnd:!0},action$$1=function(arg1,arg2,arg3,arg4){return 1===arguments.length&&"function"==typeof arg1?createAction$$1(arg1.name||"<unnamed action>",arg1):2===arguments.length&&"function"==typeof arg2?createAction$$1(arg1,arg2):1===arguments.length&&"string"==typeof arg1?namedActionDecorator$$1(arg1):!0===arg4?void addHiddenProp$$1(arg1,arg2,createAction$$1(arg1.name||arg2,arg3.value)):namedActionDecorator$$1(arg2).apply(null,arguments)};action$$1.bound=function(target,propertyName,descriptor,applyToInstance){return!0===applyToInstance?(defineBoundAction$$1(target,propertyName,descriptor.value),null):descriptor?{configurable:!0,enumerable:!1,get:function get(){return defineBoundAction$$1(this,propertyName,descriptor.value||descriptor.initializer.call(this)),this[propertyName]},set:dontReassignFields}:{enumerable:!1,configurable:!0,set:function set(v){defineBoundAction$$1(this,propertyName,v)},get:function get(){}}};var run=function(f){return f()},generatorId=0,defaultOptions={detectCycles:!0,exportMapsAsObjects:!0},objectProxyTraps={has:function has(target,name){if(name===$mobx$$1||"constructor"===name||name===mobxDidRunLazyInitializersSymbol$$1)return!0;var adm=getAdm(target);return!!adm.values.get(name)||("string"==typeof name?adm.has(name):name in target)},get:function get(target,name){if(name===$mobx$$1||"constructor"===name||name===mobxDidRunLazyInitializersSymbol$$1)return target[name];var adm=getAdm(target),observable$$1=adm.values.get(name);return observable$$1 instanceof Atom$$1?observable$$1.get():("string"==typeof name&&adm.has(name),target[name])},set:function set(target,name,value){return!("string"!=typeof name)&&(set$$1(target,name,value),!0)},deleteProperty:function deleteProperty(target,name){if("string"!=typeof name)return!1;var adm=getAdm(target);return adm.remove(name),!0},ownKeys:function ownKeys(target){var adm=getAdm(target);return adm.keysAtom.reportObserved(),Reflect.ownKeys(target)},preventExtensions:function preventExtensions(){return fail$1("Dynamic observable objects cannot be frozen"),!1}},arrayTraps={get:function get(target,name){return name===$mobx$$1?target[$mobx$$1]:"length"===name?target[$mobx$$1].getArrayLength():"number"==typeof name?arrayExtensions.get.call(target,name):"string"!=typeof name||isNaN(name)?arrayExtensions.hasOwnProperty(name)?arrayExtensions[name]:target[name]:arrayExtensions.get.call(target,parseInt(name))},set:function set(target,name,value){return"length"===name?(target[$mobx$$1].setArrayLength(value),!0):"number"==typeof name?(arrayExtensions.set.call(target,name,value),!0):!isNaN(name)&&(arrayExtensions.set.call(target,parseInt(name),value),!0)},preventExtensions:function preventExtensions(){return fail$1("Observable arrays cannot be frozen"),!1}},ObservableArrayAdministration=function(){function ObservableArrayAdministration(name,enhancer,owned){this.owned=owned,this.values=[],this.proxy=void 0,this.lastKnownLength=0,this.atom=new Atom$$1(name||"ObservableArray@"+getNextId$$1()),this.enhancer=function(newV,oldV){return enhancer(newV,oldV,name+"[..]")}}return ObservableArrayAdministration.prototype.dehanceValue=function(value){return void 0===this.dehancer?value:this.dehancer(value)},ObservableArrayAdministration.prototype.dehanceValues=function(values$$1){return void 0!==this.dehancer&&0<this.values.length?values$$1.map(this.dehancer):values$$1},ObservableArrayAdministration.prototype.intercept=function(handler){return registerInterceptor$$1(this,handler)},ObservableArrayAdministration.prototype.observe=function(listener,fireImmediately){return void 0===fireImmediately&&(fireImmediately=!1),fireImmediately&&listener({object:this.proxy,type:"splice",index:0,added:this.values.slice(),addedCount:this.values.length,removed:[],removedCount:0}),registerListener$$1(this,listener)},ObservableArrayAdministration.prototype.getArrayLength=function(){return this.atom.reportObserved(),this.values.length},ObservableArrayAdministration.prototype.setArrayLength=function(newLength){if("number"!=typeof newLength||0>newLength)throw new Error("[mobx.array] Out of range: "+newLength);var currentLength=this.values.length;if(newLength!==currentLength)if(newLength>currentLength){for(var newItems=Array(newLength-currentLength),i=0;i<newLength-currentLength;i++)newItems[i]=void 0;this.spliceWithArray(currentLength,0,newItems)}else this.spliceWithArray(newLength,currentLength-newLength)},ObservableArrayAdministration.prototype.updateArrayLength=function(oldLength,delta){if(oldLength!==this.lastKnownLength)throw new Error("[mobx] Modification exception: the internal structure of an observable array was changed.");this.lastKnownLength+=delta},ObservableArrayAdministration.prototype.spliceWithArray=function(index,deleteCount,newItems){var _this=this;checkIfStateModificationsAreAllowed$$1(this.atom);var length=this.values.length;if(void 0===index?index=0:index>length?index=length:0>index&&(index=_Mathmax(0,length+index)),deleteCount=1===arguments.length?length-index:void 0===deleteCount||null===deleteCount?0:_Mathmax(0,Math.min(deleteCount,length-index)),void 0===newItems&&(newItems=EMPTY_ARRAY$$1),hasInterceptors$$1(this)){var change=interceptChange$$1(this,{object:this.proxy,type:"splice",index:index,removedCount:deleteCount,added:newItems});if(!change)return EMPTY_ARRAY$$1;deleteCount=change.removedCount,newItems=change.added}if(newItems=0===newItems.length?newItems:newItems.map(function(v){return _this.enhancer(v,void 0)}),"production"!==process.env.NODE_ENV){var lengthDelta=newItems.length-deleteCount;this.updateArrayLength(length,lengthDelta)}var res=this.spliceItemsIntoValues(index,deleteCount,newItems);return(0!==deleteCount||0!==newItems.length)&&this.notifyArraySplice(index,newItems,res),this.dehanceValues(res)},ObservableArrayAdministration.prototype.spliceItemsIntoValues=function(index,deleteCount,newItems){var _a;if(10000>newItems.length)return(_a=this.values).splice.apply(_a,__spread([index,deleteCount],newItems));var res=this.values.slice(index,index+deleteCount);return this.values=this.values.slice(0,index).concat(newItems,this.values.slice(index+deleteCount)),res},ObservableArrayAdministration.prototype.notifyArrayChildUpdate=function(index,newValue,oldValue){var notifySpy=!this.owned&&isSpyEnabled$$1(),notify=hasListeners$$1(this),change=notify||notifySpy?{object:this.proxy,type:"update",index:index,newValue:newValue,oldValue:oldValue}:null;notifySpy&&"production"!==process.env.NODE_ENV&&spyReportStart$$1(__assign({},change,{name:this.atom.name})),this.atom.reportChanged(),notify&&notifyListeners$$1(this,change),notifySpy&&"production"!==process.env.NODE_ENV&&spyReportEnd$$1()},ObservableArrayAdministration.prototype.notifyArraySplice=function(index,added,removed){var notifySpy=!this.owned&&isSpyEnabled$$1(),notify=hasListeners$$1(this),change=notify||notifySpy?{object:this.proxy,type:"splice",index:index,removed:removed,added:added,removedCount:removed.length,addedCount:added.length}:null;notifySpy&&"production"!==process.env.NODE_ENV&&spyReportStart$$1(__assign({},change,{name:this.atom.name})),this.atom.reportChanged(),notify&&notifyListeners$$1(this,change),notifySpy&&"production"!==process.env.NODE_ENV&&spyReportEnd$$1()},ObservableArrayAdministration}(),arrayExtensions={intercept:function intercept(handler){return this[$mobx$$1].intercept(handler)},observe:function observe(listener,fireImmediately){void 0===fireImmediately&&(fireImmediately=!1);var adm=this[$mobx$$1];return adm.observe(listener,fireImmediately)},clear:function clear(){return this.splice(0)},replace:function replace(newItems){var adm=this[$mobx$$1];return adm.spliceWithArray(0,adm.values.length,newItems)},toJS:function toJS(){return this.slice()},toJSON:function toJSON(){return this.toJS()},splice:function splice(index,deleteCount){for(var newItems=[],_i=2;_i<arguments.length;_i++)newItems[_i-2]=arguments[_i];var adm=this[$mobx$$1];switch(arguments.length){case 0:return[];case 1:return adm.spliceWithArray(index);case 2:return adm.spliceWithArray(index,deleteCount);}return adm.spliceWithArray(index,deleteCount,newItems)},spliceWithArray:function spliceWithArray(index,deleteCount,newItems){var adm=this[$mobx$$1];return adm.spliceWithArray(index,deleteCount,newItems)},push:function push(){for(var items=[],_i=0;_i<arguments.length;_i++)items[_i]=arguments[_i];var adm=this[$mobx$$1];return adm.spliceWithArray(adm.values.length,0,items),adm.values.length},pop:function pop(){return this.splice(_Mathmax(this[$mobx$$1].values.length-1,0),1)[0]},shift:function shift(){return this.splice(0,1)[0]},unshift:function unshift(){for(var items=[],_i=0;_i<arguments.length;_i++)items[_i]=arguments[_i];var adm=this[$mobx$$1];return adm.spliceWithArray(0,0,items),adm.values.length},reverse:function reverse(){"production"!==process.env.NODE_ENV&&console.warn("[mobx] `observableArray.reverse()` will not update the array in place. Use `observableArray.slice().reverse()` to supress this warning and perform the operation on a copy, or `observableArray.replace(observableArray.slice().reverse())` to reverse & update in place");var clone=this.slice();return clone.reverse.apply(clone,arguments)},sort:function sort(){"production"!==process.env.NODE_ENV&&console.warn("[mobx] `observableArray.sort()` will not update the array in place. Use `observableArray.slice().sort()` to supress this warning and perform the operation on a copy, or `observableArray.replace(observableArray.slice().sort())` to sort & update in place");var clone=this.slice();return clone.sort.apply(clone,arguments)},remove:function remove(value){var adm=this[$mobx$$1],idx=adm.dehanceValues(adm.values).indexOf(value);return!!(-1<idx)&&(this.splice(idx,1),!0)},get:function get(index){var adm=this[$mobx$$1];if(adm){if(index<adm.values.length)return adm.atom.reportObserved(),adm.dehanceValue(adm.values[index]);console.warn("[mobx.array] Attempt to read an array index ("+index+") that is out of bounds ("+adm.values.length+"). Please check length first. Out of bound indices will not be tracked by MobX")}},set:function set(index,newValue){var adm=this[$mobx$$1],values$$1=adm.values;if(index<values$$1.length){checkIfStateModificationsAreAllowed$$1(adm.atom);var oldValue=values$$1[index];if(hasInterceptors$$1(adm)){var change=interceptChange$$1(adm,{type:"update",object:this,index:index,newValue:newValue});if(!change)return;newValue=change.newValue}newValue=adm.enhancer(newValue,oldValue);var changed=newValue!==oldValue;changed&&(values$$1[index]=newValue,adm.notifyArrayChildUpdate(index,newValue,oldValue))}else if(index===values$$1.length)adm.spliceWithArray(index,0,[newValue]);else throw new Error("[mobx.array] Index out of bounds, "+index+" is larger than "+values$$1.length)}};["every","filter","forEach","indexOf","join","lastIndexOf","map","reduce","reduceRight","slice","some","toString","toLocaleString"].forEach(function(funcName){arrayExtensions[funcName]=function(){var adm=this[$mobx$$1];adm.atom.reportObserved();var res=adm.dehanceValues(adm.values);return res[funcName].apply(res,arguments)}});var _a,isObservableArrayAdministration=createInstanceofPredicate$$1("ObservableArrayAdministration",ObservableArrayAdministration),ObservableMapMarker={},ObservableMap$$1=function(){function ObservableMap$$1(initialData,enhancer,name){if(void 0===enhancer&&(enhancer=deepEnhancer$$1),void 0===name&&(name="ObservableMap@"+getNextId$$1()),this.enhancer=enhancer,this.name=name,this[_a]=ObservableMapMarker,this._keysAtom=createAtom$$1(this.name+".keys()"),this[Symbol.toStringTag]="Map","function"!=typeof Map)throw new Error("mobx.map requires Map polyfill for the current browser. Check babel-polyfill or core-js/es6/map.js");this._data=new Map,this._hasMap=new Map,this.merge(initialData)}return ObservableMap$$1.prototype._has=function(key){return this._data.has(key)},ObservableMap$$1.prototype.has=function(key){return this._hasMap.has(key)?this._hasMap.get(key).get():this._updateHasMapEntry(key,!1).get()},ObservableMap$$1.prototype.set=function(key,value){var hasKey=this._has(key);if(hasInterceptors$$1(this)){var change=interceptChange$$1(this,{type:hasKey?"update":"add",object:this,newValue:value,name:key});if(!change)return this;value=change.newValue}return hasKey?this._updateValue(key,value):this._addValue(key,value),this},ObservableMap$$1.prototype.delete=function(key){var _this=this;if(hasInterceptors$$1(this)){var change=interceptChange$$1(this,{type:"delete",object:this,name:key});if(!change)return!1}if(this._has(key)){var notifySpy=isSpyEnabled$$1(),notify=hasListeners$$1(this),change=notify||notifySpy?{type:"delete",object:this,oldValue:this._data.get(key).value,name:key}:null;return notifySpy&&"production"!==process.env.NODE_ENV&&spyReportStart$$1(__assign({},change,{name:this.name,key:key})),transaction$$1(function(){_this._keysAtom.reportChanged(),_this._updateHasMapEntry(key,!1);var observable$$1=_this._data.get(key);observable$$1.setNewValue(void 0),_this._data.delete(key)}),notify&&notifyListeners$$1(this,change),notifySpy&&"production"!==process.env.NODE_ENV&&spyReportEnd$$1(),!0}return!1},ObservableMap$$1.prototype._updateHasMapEntry=function(key,value){var entry=this._hasMap.get(key);return entry?entry.setNewValue(value):(entry=new ObservableValue$$1(value,referenceEnhancer$$1,this.name+"."+key+"?",!1),this._hasMap.set(key,entry)),entry},ObservableMap$$1.prototype._updateValue=function(key,newValue){var observable$$1=this._data.get(key);if(newValue=observable$$1.prepareNewValue(newValue),newValue!==UNCHANGED$$1){var notifySpy=isSpyEnabled$$1(),notify=hasListeners$$1(this),change=notify||notifySpy?{type:"update",object:this,oldValue:observable$$1.value,name:key,newValue:newValue}:null;notifySpy&&"production"!==process.env.NODE_ENV&&spyReportStart$$1(__assign({},change,{name:this.name,key:key})),observable$$1.setNewValue(newValue),notify&&notifyListeners$$1(this,change),notifySpy&&"production"!==process.env.NODE_ENV&&spyReportEnd$$1()}},ObservableMap$$1.prototype._addValue=function(key,newValue){var _this=this;checkIfStateModificationsAreAllowed$$1(this._keysAtom),transaction$$1(function(){var observable$$1=new ObservableValue$$1(newValue,_this.enhancer,_this.name+"."+key,!1);_this._data.set(key,observable$$1),newValue=observable$$1.value,_this._updateHasMapEntry(key,!0),_this._keysAtom.reportChanged()});var notifySpy=isSpyEnabled$$1(),notify=hasListeners$$1(this),change=notify||notifySpy?{type:"add",object:this,name:key,newValue:newValue}:null;notifySpy&&"production"!==process.env.NODE_ENV&&spyReportStart$$1(__assign({},change,{name:this.name,key:key})),notify&&notifyListeners$$1(this,change),notifySpy&&"production"!==process.env.NODE_ENV&&spyReportEnd$$1()},ObservableMap$$1.prototype.get=function(key){return this.has(key)?this.dehanceValue(this._data.get(key).get()):this.dehanceValue(void 0)},ObservableMap$$1.prototype.dehanceValue=function(value){return void 0===this.dehancer?value:this.dehancer(value)},ObservableMap$$1.prototype.keys=function(){return this._keysAtom.reportObserved(),this._data.keys()},ObservableMap$$1.prototype.values=function(){var self=this,nextIndex=0,keys$$1=Array.from(this.keys());return makeIterable({next:function next(){return nextIndex<keys$$1.length?{value:self.get(keys$$1[nextIndex++]),done:!1}:{done:!0}}})},ObservableMap$$1.prototype.entries=function(){var self=this,nextIndex=0,keys$$1=Array.from(this.keys());return makeIterable({next:function next(){if(nextIndex<keys$$1.length){var key=keys$$1[nextIndex++];return{value:[key,self.get(key)],done:!1}}return{done:!0}}})},ObservableMap$$1.prototype[(_a=$mobx$$1,Symbol.iterator)]=function(){return this.entries()},ObservableMap$$1.prototype.forEach=function(callback,thisArg){var e_1,_a;try{for(var _b=__values(this),_c=_b.next();!_c.done;_c=_b.next()){var _d=__read(_c.value,2),key=_d[0],value=_d[1];callback.call(thisArg,value,key,this)}}catch(e_1_1){e_1={error:e_1_1}}finally{try{_c&&!_c.done&&(_a=_b.return)&&_a.call(_b)}finally{if(e_1)throw e_1.error}}},ObservableMap$$1.prototype.merge=function(other){var _this=this;return isObservableMap$$1(other)&&(other=other.toJS()),transaction$$1(function(){isPlainObject$$1(other)?Object.keys(other).forEach(function(key){return _this.set(key,other[key])}):Array.isArray(other)?other.forEach(function(_a){var _b=__read(_a,2),key=_b[0],value=_b[1];return _this.set(key,value)}):isES6Map$$1(other)?other.forEach(function(value,key){return _this.set(key,value)}):null!==other&&void 0!==other&&fail$1("Cannot initialize map from "+other)}),this},ObservableMap$$1.prototype.clear=function(){var _this=this;transaction$$1(function(){untracked$$1(function(){var e_2,_a;try{for(var key,_b=__values(_this.keys()),_c=_b.next();!_c.done;_c=_b.next())key=_c.value,_this.delete(key)}catch(e_2_1){e_2={error:e_2_1}}finally{try{_c&&!_c.done&&(_a=_b.return)&&_a.call(_b)}finally{if(e_2)throw e_2.error}}})})},ObservableMap$$1.prototype.replace=function(values$$1){var _this=this;return transaction$$1(function(){var newKeys=getMapLikeKeys$$1(values$$1),oldKeys=Array.from(_this.keys()),missingKeys=oldKeys.filter(function(k){return-1===newKeys.indexOf(k)});missingKeys.forEach(function(k){return _this.delete(k)}),_this.merge(values$$1)}),this},Object.defineProperty(ObservableMap$$1.prototype,"size",{get:function get(){return this._keysAtom.reportObserved(),this._data.size},enumerable:!0,configurable:!0}),ObservableMap$$1.prototype.toPOJO=function(){var e_3,_a,res={};try{for(var _b=__values(this),_c=_b.next();!_c.done;_c=_b.next()){var _d=__read(_c.value,2),key=_d[0],value=_d[1];res[""+key]=value}}catch(e_3_1){e_3={error:e_3_1}}finally{try{_c&&!_c.done&&(_a=_b.return)&&_a.call(_b)}finally{if(e_3)throw e_3.error}}return res},ObservableMap$$1.prototype.toJS=function(){return new Map(this)},ObservableMap$$1.prototype.toJSON=function(){return this.toPOJO()},ObservableMap$$1.prototype.toString=function(){var _this=this;return this.name+"[{ "+Array.from(this.keys()).map(function(key){return key+": "+(""+_this.get(key))}).join(", ")+" }]"},ObservableMap$$1.prototype.observe=function(listener,fireImmediately){return"production"!==process.env.NODE_ENV&&invariant$$1(!0!==fireImmediately,"`observe` doesn't support fireImmediately=true in combination with maps."),registerListener$$1(this,listener)},ObservableMap$$1.prototype.intercept=function(handler){return registerInterceptor$$1(this,handler)},ObservableMap$$1}(),isObservableMap$$1=createInstanceofPredicate$$1("ObservableMap",ObservableMap$$1),ObservableObjectAdministration$$1=function(){function ObservableObjectAdministration$$1(target,values$$1,name,defaultEnhancer){void 0===values$$1&&(values$$1=new Map),this.target=target,this.values=values$$1,this.name=name,this.defaultEnhancer=defaultEnhancer,this.keysAtom=new Atom$$1(name+".keys")}return ObservableObjectAdministration$$1.prototype.read=function(key){return this.values.get(key).get()},ObservableObjectAdministration$$1.prototype.write=function(key,newValue){var instance=this.target,observable$$1=this.values.get(key);if(observable$$1 instanceof ComputedValue$$1)return void observable$$1.set(newValue);if(hasInterceptors$$1(this)){var change=interceptChange$$1(this,{type:"update",object:this.proxy||instance,name:key,newValue:newValue});if(!change)return;newValue=change.newValue}if(newValue=observable$$1.prepareNewValue(newValue),newValue!==UNCHANGED$$1){var notify=hasListeners$$1(this),notifySpy=isSpyEnabled$$1(),change=notify||notifySpy?{type:"update",object:this.proxy||instance,oldValue:observable$$1.value,name:key,newValue:newValue}:null;notifySpy&&"production"!==process.env.NODE_ENV&&spyReportStart$$1(__assign({},change,{name:this.name,key:key})),observable$$1.setNewValue(newValue),notify&&notifyListeners$$1(this,change),notifySpy&&"production"!==process.env.NODE_ENV&&spyReportEnd$$1()}},ObservableObjectAdministration$$1.prototype.has=function(key){return!!(this.values.get(key)instanceof ObservableValue$$1)||(this.waitForKey(key),!1)},ObservableObjectAdministration$$1.prototype.waitForKey=function(key){var map=this.pendingKeys||(this.pendingKeys=new Map),entry=map.get(key);entry||(entry=new ObservableValue$$1(!1,referenceEnhancer$$1,this.name+"."+key.toString()+"?",!1),map.set(key,entry)),entry.get()},ObservableObjectAdministration$$1.prototype.addObservableProp=function(propName,newValue,enhancer){void 0===enhancer&&(enhancer=this.defaultEnhancer);var target=this.target;if(assertPropertyConfigurable$$1(target,propName),hasInterceptors$$1(this)){var change=interceptChange$$1(this,{object:this.proxy||target,name:propName,type:"add",newValue:newValue});if(!change)return;newValue=change.newValue}var observable$$1=new ObservableValue$$1(newValue,enhancer,this.name+"."+propName,!1);this.values.set(propName,observable$$1),newValue=observable$$1.value,Object.defineProperty(target,propName,generateObservablePropConfig$$1(propName)),this.notifyPropertyAddition(propName,newValue)},ObservableObjectAdministration$$1.prototype.addComputedProp=function(propertyOwner,propName,options){var target=this.target;options.name=options.name||this.name+"."+propName,this.values.set(propName,new ComputedValue$$1(options)),(propertyOwner===target||isPropertyConfigurable$$1(propertyOwner,propName))&&Object.defineProperty(propertyOwner,propName,generateComputedPropConfig$$1(propName))},ObservableObjectAdministration$$1.prototype.remove=function(key){if(this.values.has(key)){var target=this.target;if(hasInterceptors$$1(this)){var change=interceptChange$$1(this,{object:this.proxy||target,name:key,type:"remove"});if(!change)return}try{startBatch$$1();var notify=hasListeners$$1(this),notifySpy=isSpyEnabled$$1(),oldObservable=this.values.get(key),oldValue=oldObservable&&oldObservable.get();oldObservable&&oldObservable.set(void 0),this.keysAtom.reportChanged(),this.values.delete(key),delete this.target[key];var change=notify||notifySpy?{type:"remove",object:this.proxy||target,oldValue:oldValue,name:key}:null;notifySpy&&"production"!==process.env.NODE_ENV&&spyReportStart$$1(__assign({},change,{name:this.name,key:key})),notify&&notifyListeners$$1(this,change),notifySpy&&"production"!==process.env.NODE_ENV&&spyReportEnd$$1()}finally{endBatch$$1()}}},ObservableObjectAdministration$$1.prototype.illegalAccess=function(owner,propName){console.warn("Property '"+propName+"' of '"+owner+"' was accessed through the prototype chain. Use 'decorate' instead to declare the prop or access it statically through it's owner")},ObservableObjectAdministration$$1.prototype.observe=function(callback,fireImmediately){return"production"!==process.env.NODE_ENV&&invariant$$1(!0!==fireImmediately,"`observe` doesn't support the fire immediately property for observable objects."),registerListener$$1(this,callback)},ObservableObjectAdministration$$1.prototype.intercept=function(handler){return registerInterceptor$$1(this,handler)},ObservableObjectAdministration$$1.prototype.notifyPropertyAddition=function(key,newValue){var notify=hasListeners$$1(this),notifySpy=isSpyEnabled$$1(),change=notify||notifySpy?{type:"add",object:this.proxy||this.target,name:key,newValue:newValue}:null;if(notifySpy&&"production"!==process.env.NODE_ENV&&spyReportStart$$1(__assign({},change,{name:this.name,key:key})),notify&&notifyListeners$$1(this,change),notifySpy&&"production"!==process.env.NODE_ENV&&spyReportEnd$$1(),this.pendingKeys){var entry=this.pendingKeys.get(key);entry&&entry.set(!0)}this.keysAtom.reportChanged()},ObservableObjectAdministration$$1.prototype.getKeys=function(){var e_1,_a;this.keysAtom.reportObserved();var res=[];try{for(var _b=__values(this.values),_c=_b.next();!_c.done;_c=_b.next()){var _d=__read(_c.value,2),key=_d[0],value=_d[1];value instanceof ObservableValue$$1&&res.push(key)}}catch(e_1_1){e_1={error:e_1_1}}finally{try{_c&&!_c.done&&(_a=_b.return)&&_a.call(_b)}finally{if(e_1)throw e_1.error}}return res},ObservableObjectAdministration$$1}(),observablePropertyConfigs={},computedPropertyConfigs={},isObservableObjectAdministration=createInstanceofPredicate$$1("ObservableObjectAdministration",ObservableObjectAdministration$$1),toString=Object.prototype.toString;if("undefined"==typeof Proxy)throw new Error("[mobx] MobX 5+ requires Proxy objects. If your environment doesn't support Proxy objects, please downgrade to MobX 4.");try{process.env.NODE_ENV}catch(e){var g="undefined"==typeof window?global:window;"undefined"==typeof process&&(g.process={}),g.process.env={}}(function(){"testCodeMinification"!==function(){}.name&&"production"!==process.env.NODE_ENV&&console.warn("[mobx] you are running a minified build, but 'process.env.NODE_ENV' was not set to 'production' in your bundler. This results in an unnecessarily large and slow bundle")})(),"object"===("undefined"==typeof __MOBX_DEVTOOLS_GLOBAL_HOOK__?"undefined":_typeof(__MOBX_DEVTOOLS_GLOBAL_HOOK__))&&__MOBX_DEVTOOLS_GLOBAL_HOOK__.injectMobx({spy:spy$$1,extras:{getDebugName:getDebugName$$1},$mobx:$mobx$$1}),exports.Reaction=Reaction$$1,exports.untracked=untracked$$1,exports.createAtom=createAtom$$1,exports.spy=spy$$1,exports.comparer=comparer$$1,exports.isObservableObject=isObservableObject$$1,exports.isBoxedObservable=isObservableValue$$1,exports.isObservableArray=isObservableArray$$1,exports.ObservableMap=ObservableMap$$1,exports.isObservableMap=isObservableMap$$1,exports.transaction=transaction$$1,exports.observable=observable$$1,exports.computed=computed$$1,exports.isObservable=isObservable$$1,exports.isObservableProp=function(value,propName){return"string"==typeof propName?_isObservable(value,propName):fail$1("production"!==process.env.NODE_ENV&&"expected a property name as second argument")},exports.isComputed=isComputed$$1,exports.isComputedProp=function(value,propName){return"string"==typeof propName?_isComputed$$1(value,propName):fail$1("production"!==process.env.NODE_ENV&&"isComputed expected a property name as second argument")},exports.extendObservable=extendObservable$$1,exports.observe=function(thing,propOrCb,cbOrFire,fireImmediately){return"function"==typeof cbOrFire?observeObservableProperty(thing,propOrCb,cbOrFire,fireImmediately):observeObservable(thing,propOrCb,cbOrFire)},exports.intercept=function(thing,propOrHandler,handler){return"function"==typeof handler?interceptProperty(thing,propOrHandler,handler):interceptInterceptable(thing,propOrHandler)},exports.autorun=autorun$$1,exports.reaction=function(expression,effect,opts){function reactionRunner(){if(isScheduled=!1,!r.isDisposed){var changed=!1;r.track(function(){var nextValue=expression(r);changed=firstTime||!equals(value,nextValue),value=nextValue}),firstTime&&opts.fireImmediately&&effectAction(value,r),firstTime||!0!==changed||effectAction(value,r),firstTime&&(firstTime=!1)}}void 0===opts&&(opts=EMPTY_OBJECT$$1),"production"!==process.env.NODE_ENV&&(invariant$$1("function"==typeof expression,"First argument to reaction should be a function"),invariant$$1("object"===("undefined"==typeof opts?"undefined":_typeof(opts)),"Third argument of reactions should be an object"));var value,name=opts.name||"Reaction@"+getNextId$$1(),effectAction=action$$1(name,opts.onError?wrapErrorHandler(opts.onError,effect):effect),runSync=!opts.scheduler&&!opts.delay,scheduler=createSchedulerFromOptions(opts),firstTime=!0,isScheduled=!1,equals=opts.compareStructural?comparer$$1.structural:opts.equals||comparer$$1.default,r=new Reaction$$1(name,function(){firstTime||runSync?reactionRunner():!isScheduled&&(isScheduled=!0,scheduler(reactionRunner))},opts.onError);return r.schedule(),r.getDisposer()},exports.when=function(predicate,arg1,arg2){return 1===arguments.length||arg1&&"object"===("undefined"==typeof arg1?"undefined":_typeof(arg1))?whenPromise(predicate,arg1):_when(predicate,arg1,arg2||{})},exports.action=action$$1,exports.isAction=isAction$$1,exports.runInAction=function(arg1,arg2){var actionName="string"==typeof arg1?arg1:arg1.name||"<unnamed action>",fn="function"==typeof arg1?arg1:arg2;return"production"!==process.env.NODE_ENV&&(invariant$$1("function"==typeof fn&&0===fn.length,"`runInAction` expects a function without arguments"),("string"!=typeof actionName||!actionName)&&fail$1("actions should have valid names, got: '"+actionName+"'")),executeAction$$1(actionName,fn,this,void 0)},exports.keys=keys$$1,exports.values=function(obj){return isObservableObject$$1(obj)?keys$$1(obj).map(function(key){return obj[key]}):isObservableMap$$1(obj)?keys$$1(obj).map(function(key){return obj.get(key)}):isObservableArray$$1(obj)?obj.slice():fail$1("production"!==process.env.NODE_ENV&&"'values()' can only be used on observable objects, arrays and maps")},exports.entries=function(obj){return isObservableObject$$1(obj)?keys$$1(obj).map(function(key){return[key,obj[key]]}):isObservableMap$$1(obj)?keys$$1(obj).map(function(key){return[key,obj.get(key)]}):isObservableArray$$1(obj)?obj.map(function(key,index){return[index,key]}):fail$1("production"!==process.env.NODE_ENV&&"'entries()' can only be used on observable objects, arrays and maps")},exports.set=set$$1,exports.remove=function(obj,key){if(isObservableObject$$1(obj))obj[$mobx$$1].remove(key);else if(isObservableMap$$1(obj))obj.delete(key);else if(isObservableArray$$1(obj))"number"!=typeof key&&(key=parseInt(key,10)),invariant$$1(0<=key,"Not a valid index: '"+key+"'"),obj.splice(key,1);else return fail$1("production"!==process.env.NODE_ENV&&"'remove()' can only be used on observable objects, arrays and maps")},exports.has=has$$1,exports.get=function(obj,key){return has$$1(obj,key)?isObservableObject$$1(obj)?obj[key]:isObservableMap$$1(obj)?obj.get(key):isObservableArray$$1(obj)?obj[key]:fail$1("production"!==process.env.NODE_ENV&&"'get()' can only be used on observable objects, arrays and maps"):void 0},exports.decorate=function(thing,decorators){"production"!==process.env.NODE_ENV&&invariant$$1(isPlainObject$$1(decorators),"Decorators should be a key value map");var target="function"==typeof thing?thing.prototype:thing;for(var prop in decorators){var decorator=decorators[prop];"production"!==process.env.NODE_ENV&&invariant$$1("function"==typeof decorator,"Decorate: expected a decorator function for '"+prop+"'");var descriptor=Object.getOwnPropertyDescriptor(target,prop),newDescriptor=decorator(target,prop,descriptor);newDescriptor&&Object.defineProperty(target,prop,newDescriptor)}return thing},exports.configure=configure$$1,exports.onBecomeObserved=onBecomeObserved$$1,exports.onBecomeUnobserved=onBecomeUnobserved$$1,exports.flow=function(generator){1!==arguments.length&&fail$1(process.env.NODE_ENV&&"Flow expects one 1 argument and cannot be used as decorator");var name=generator.name||"<unnamed flow>";return function(){var rejector,ctx=this,args=arguments,runId=++generatorId,gen=action$$1(name+" - runid: "+runId+" - init",generator).apply(ctx,args),pendingPromise=void 0,res=new Promise(function(resolve,reject){function onFulfilled(res){pendingPromise=void 0;var ret;try{ret=action$$1(name+" - runid: "+runId+" - yield "+stepId++,gen.next).call(gen,res)}catch(e){return reject(e)}next(ret)}function onRejected(err){pendingPromise=void 0;var ret;try{ret=action$$1(name+" - runid: "+runId+" - yield "+stepId++,gen.throw).call(gen,err)}catch(e){return reject(e)}next(ret)}function next(ret){return ret&&"function"==typeof ret.then?void ret.then(next,reject):ret.done?resolve(ret.value):(pendingPromise=Promise.resolve(ret.value),pendingPromise.then(onFulfilled,onRejected))}var stepId=0;rejector=reject,onFulfilled(void 0)});return res.cancel=action$$1(name+" - runid: "+runId+" - cancel",function(){try{pendingPromise&&cancelPromise(pendingPromise);var res_1=gen.return(),yieldedPromise=Promise.resolve(res_1.value);yieldedPromise.then(noop$$1,noop$$1),cancelPromise(yieldedPromise),rejector(new Error("FLOW_CANCELLED"))}catch(e){rejector(e)}}),res}},exports.toJS=function(source,options){if(!isObservable$$1(source))return source;"boolean"==typeof options&&(options={detectCycles:options}),options||(options=defaultOptions);var __alreadySeen,detectCycles=!0===options.detectCycles;return detectCycles&&(__alreadySeen=new Map),toJSHelper(source,options,__alreadySeen)},exports.trace=trace$$1,exports.getDependencyTree=getDependencyTree$$1,exports.getObserverTree=function(thing,property){return nodeToObserverTree(getAtom$$1(thing,property))},exports._resetGlobalState=function(){var defaultGlobals=new MobXGlobals$$1;for(var key in defaultGlobals)-1===persistentKeys.indexOf(key)&&(globalState$$1[key]=defaultGlobals[key]);globalState$$1.allowStateChanges=!globalState$$1.enforceActions},exports._getGlobalState=function(){return globalState$$1},exports.getDebugName=getDebugName$$1,exports.getAtom=getAtom$$1,exports._getAdministration=getAdministration$$1,exports._allowStateChanges=allowStateChanges$$1,exports.isArrayLike=function(x){return Array.isArray(x)||isObservableArray$$1(x)},exports.$mobx=$mobx$$1,exports._isComputingDerivation=function(){return null!==globalState$$1.trackingDerivation},exports.onReactionError=function(handler){return globalState$$1.globalReactionErrorHandlers.push(handler),function(){var idx=globalState$$1.globalReactionErrorHandlers.indexOf(handler);0<=idx&&globalState$$1.globalReactionErrorHandlers.splice(idx,1)}},exports._interceptReads=function(thing,propOrHandler,handler){var target;if(isObservableMap$$1(thing)||isObservableArray$$1(thing)||isObservableValue$$1(thing))target=getAdministration$$1(thing);else if(isObservableObject$$1(thing)){if("string"!=typeof propOrHandler)return fail$1("production"!==process.env.NODE_ENV&&"InterceptReads can only be used with a specific property, not with an object in general");target=getAdministration$$1(thing,propOrHandler)}else return fail$1("production"!==process.env.NODE_ENV&&"Expected observable map, object or array as first array");return void 0===target.dehancer?(target.dehancer="function"==typeof propOrHandler?propOrHandler:handler,function(){target.dehancer=void 0}):fail$1("production"!==process.env.NODE_ENV&&"An intercept reader was already established")}}).call(this,require("_process"),"undefined"==typeof global?"undefined"==typeof self?"undefined"==typeof window?{}:window:self:global)},{_process:2}],2:[function(require,module){function defaultSetTimout(){throw new Error("setTimeout has not been defined")}function defaultClearTimeout(){throw new Error("clearTimeout has not been defined")}function runTimeout(fun){if(cachedSetTimeout===setTimeout)return setTimeout(fun,0);if((cachedSetTimeout===defaultSetTimout||!cachedSetTimeout)&&setTimeout)return cachedSetTimeout=setTimeout,setTimeout(fun,0);try{return cachedSetTimeout(fun,0)}catch(e){try{return cachedSetTimeout.call(null,fun,0)}catch(e){return cachedSetTimeout.call(this,fun,0)}}}function runClearTimeout(marker){if(cachedClearTimeout===clearTimeout)return clearTimeout(marker);if((cachedClearTimeout===defaultClearTimeout||!cachedClearTimeout)&&clearTimeout)return cachedClearTimeout=clearTimeout,clearTimeout(marker);try{return cachedClearTimeout(marker)}catch(e){try{return cachedClearTimeout.call(null,marker)}catch(e){return cachedClearTimeout.call(this,marker)}}}function cleanUpNextTick(){draining&&currentQueue&&(draining=!1,currentQueue.length?queue=currentQueue.concat(queue):queueIndex=-1,queue.length&&drainQueue())}function drainQueue(){if(!draining){var timeout=runTimeout(cleanUpNextTick);draining=!0;for(var len=queue.length;len;){for(currentQueue=queue,queue=[];++queueIndex<len;)currentQueue&&currentQueue[queueIndex].run();queueIndex=-1,len=queue.length}currentQueue=null,draining=!1,runClearTimeout(timeout)}}function Item(fun,array){this.fun=fun,this.array=array}function noop(){}var cachedSetTimeout,cachedClearTimeout,process=module.exports={};(function(){try{cachedSetTimeout="function"==typeof setTimeout?setTimeout:defaultSetTimout}catch(e){cachedSetTimeout=defaultSetTimout}try{cachedClearTimeout="function"==typeof clearTimeout?clearTimeout:defaultClearTimeout}catch(e){cachedClearTimeout=defaultClearTimeout}})();var currentQueue,queue=[],draining=!1,queueIndex=-1;process.nextTick=function(fun){var args=Array(arguments.length-1);if(1<arguments.length)for(var i=1;i<arguments.length;i++)args[i-1]=arguments[i];queue.push(new Item(fun,args)),1!==queue.length||draining||runTimeout(drainQueue)},Item.prototype.run=function(){this.fun.apply(null,this.array)},process.title="browser",process.browser=!0,process.env={},process.argv=[],process.version="",process.versions={},process.on=noop,process.addListener=noop,process.once=noop,process.off=noop,process.removeListener=noop,process.removeAllListeners=noop,process.emit=noop,process.prependListener=noop,process.prependOnceListener=noop,process.listeners=function(){return[]},process.binding=function(){throw new Error("process.binding is not supported")},process.cwd=function(){return"/"},process.chdir=function(){throw new Error("process.chdir is not supported")},process.umask=function(){return 0}},{}]},{},[1])(1)});
//# sourceMappingURL=mobx.min.js.map
