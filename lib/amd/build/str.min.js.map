{"version":3,"sources":["../src/str.js"],"names":["promiseCache","get_string","key","component","param","lang","get_strings","then","results","requests","requestData","pageLang","attr","replace","getCacheKey","stringPromises","map","request","cacheKey","buildReturn","promise","M","str","Promise","resolve","cached","LocalStorage","get","reject","push","methodname","args","stringid","stringparams","done","set","fail","length","Ajax","call","$","when","apply","strings"],"mappings":"4zBAgCIA,aAAe,E,CAYNC,8BAAa,SAACC,GAAD,CAAMC,SAAN,CAAiBC,KAAjB,CAAwBC,IAAxB,CAAiC,CACvD,MAAOC,aAAY,CAAC,CAAEJ,OAAF,CAAOC,mBAAP,CAAkBC,WAAlB,CAAyBC,SAAzB,CAAD,CAAZ,EACFE,IADE,CACG,wBAAWC,SAAQ,CAAR,CAAX,CADH,CAEV,C,CAUYF,gCAAc,SAACG,QAAD,CAAc,IACjCC,aAAc,EADmB,CAE/BC,SAAW,qBAAE,MAAF,EAAUC,IAAV,CAAe,MAAf,EAAuBC,OAAvB,CAA+B,IAA/B,CAAqC,GAArC,CAFoB,CAI/BC,YAAc,kBAAGZ,IAAH,MAAGA,GAAH,CAAQC,SAAR,MAAQA,SAAR,gBAAmBE,IAAnB,CAAmBA,IAAnB,oBAA0BM,QAA1B,6BAAqDT,GAArD,KAA4DC,SAA5D,KAAyEE,IAAzE,CAJiB,CAM/BU,eAAiBN,SAASO,GAAT,CAAa,SAACC,OAAD,CAAa,IACvCC,UAAWJ,YAAYG,OAAZ,CAD4B,CAErCd,SAFqC,CAEZc,OAFY,CAErCd,SAFqC,CAE1BD,GAF0B,CAEZe,OAFY,CAE1Bf,GAF0B,CAErBG,IAFqB,CAEZY,OAFY,CAErBZ,IAFqB,CAIvCc,YAAc,SAACC,OAAD,CAAa,CAG7B,MADApB,cAAakB,QAAb,EAAyBE,OACzB,CAAOA,OACV,CAR4C,CAW7C,GAAIjB,YAAakB,GAAEC,GAAf,EAAsBpB,MAAOmB,GAAEC,GAAF,CAAMnB,SAAN,CAAjC,CACI,MAAOgB,aAAY,GAAII,QAAJ,CAAY,SAACC,OAAD,CAAa,CACxCA,QAAQH,EAAEC,GAAF,CAAMnB,SAAN,EAAiBD,GAAjB,CAAR,CACH,CAFkB,CAAZ,CAAP,CAMJ,GAAMuB,QAASC,uBAAaC,GAAb,CAAiBT,QAAjB,CAAf,CAlB6C,MAmBzCO,OAnByC,EAoBzCJ,EAAEC,GAAF,CAAMnB,SAAN,cAAuBkB,EAAEC,GAAF,CAAMnB,SAAN,CAAvB,oBAA0CD,GAA1C,CAAgDuB,MAAhD,EApByC,CAqBlCN,YAAY,GAAII,QAAJ,CAAY,SAACC,OAAD,CAAa,CACxCA,QAAQH,EAAEC,GAAF,CAAMnB,SAAN,EAAiBD,GAAjB,CAAR,CACH,CAFkB,CAAZ,CArBkC,EA2BzCgB,WAAYlB,aA3B6B,CA4BlCmB,YAAYnB,aAAakB,QAAb,CAAZ,CA5BkC,CAgClCC,YAAY,GAAII,QAAJ,CAAY,SAACC,OAAD,CAAUI,MAAV,CAAqB,CAChDlB,YAAYmB,IAAZ,CAAiB,CACbC,WAAY,iBADC,CAEbC,KAAM,CACFC,SAAU9B,GADR,CAEF+B,aAAc,EAFZ,CAGF9B,mBAHE,CAIFE,SAJE,CAFO,CAQb6B,KAAM,cAACZ,GAAD,CAAS,CAIXD,EAAEC,GAAF,CAAMnB,SAAN,cAAuBkB,EAAEC,GAAF,CAAMnB,SAAN,CAAvB,oBAA0CD,GAA1C,CAAgDoB,GAAhD,EAJW,CAKXI,uBAAaS,GAAb,CAAiBjB,QAAjB,CAA2BI,GAA3B,CALW,CAMXE,QAAQF,GAAR,CACH,CAfY,CAgBbc,KAAMR,MAhBO,CAAjB,CAkBH,CAnBkB,CAAZ,CAqBd,CArDsB,CANc,CAqErC,MARIlB,aAAY2B,MAQhB,EALIC,eAAKC,IAAL,CAAU7B,WAAV,OAKJ,CAAO8B,iBAAEC,IAAF,CAAOC,KAAP,CAAaF,gBAAb,CAAgBzB,cAAhB,EACFR,IADE,CACG,yCAAIoC,OAAJ,qCAAIA,OAAJ,6BAAgBA,QAAhB,CADH,CAEV,C","file":"str.min.js","sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * Fetch and render language strings.\n * Hooks into the old M.str global - but can also fetch missing strings on the fly.\n *\n * @module     core/str\n * @class      str\n * @package    core\n * @copyright  2015 Damyon Wiese <damyon@moodle.com>\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n * @since      2.9\n */\nimport $ from 'jquery'\nimport Ajax from 'core/ajax'\nimport LocalStorage from 'core/localstorage'\n\n// Module cache for the promises so that we don't make multiple\n// unnecessary requests.\nlet promiseCache = []\n\n/**\n * Return a promise object that will be resolved into a string eventually (maybe immediately).\n *\n * @method get_string\n * @param {string} key The language string key\n * @param {string} component The language string component\n * @param {string} param The param for variable expansion in the string.\n * @param {string} lang The users language - if not passed it is deduced.\n * @return {Promise}\n */\nexport const get_string = (key, component, param, lang) => {\n    return get_strings([{ key, component, param, lang }])\n        .then(results => results[0])\n}\n\n/**\n * Make a batch request to load a set of strings\n *\n * @method get_strings\n * @param {Object[]} requests Array of { key: key, component: component, param: param, lang: lang };\n *                                      See get_string for more info on these args.\n * @return {Promise}\n */\nexport const get_strings = (requests) => {\n    let requestData = []\n    const pageLang = $('html').attr('lang').replace(/-/g, '_')\n    // Helper function to construct the cache key.\n    const getCacheKey = ({ key, component, lang = pageLang }) => `core_str/${key}/${component}/${lang}`\n\n    const stringPromises = requests.map((request) => {\n        const cacheKey = getCacheKey(request)\n        const { component, key, lang } = request;\n        // Helper function to add the promise to cache.\n        const buildReturn = (promise) => {\n            // Make sure the promise cache contains our promise.\n            promiseCache[cacheKey] = promise\n            return promise\n        }\n\n        // Check if we can serve the string straight from M.str.\n        if (component in M.str && key in M.str[component]) {\n            return buildReturn(new Promise((resolve) => {\n                resolve(M.str[component][key])\n            }))\n        }\n\n        // Check if the string is in the browser's local storage.\n        const cached = LocalStorage.get(cacheKey)\n        if (cached) {\n            M.str[component] = {...M.str[component], [key]: cached}\n            return buildReturn(new Promise((resolve) => {\n                resolve(M.str[component][key])\n            }))\n        }\n\n        // Check if we've already loaded this string from the server.\n        if (cacheKey in promiseCache) {\n            return buildReturn(promiseCache[cacheKey])\n        } else {\n            // We're going to have to ask the server for the string so\n            // add this string to the list of requests to be sent.\n            return buildReturn(new Promise((resolve, reject) => {\n                requestData.push({\n                    methodname: 'core_get_string',\n                    args: {\n                        stringid: key,\n                        stringparams: [],\n                        component,\n                        lang,\n                    },\n                    done: (str) => {\n                        // When we get the response from the server\n                        // we should update M.str and the browser's\n                        // local storage before resolving this promise.\n                        M.str[component] = {...M.str[component], [key]: str}\n                        LocalStorage.set(cacheKey, str)\n                        resolve(str)\n                    },\n                    fail: reject\n                })\n            }))\n        }\n    })\n\n    if (requestData.length) {\n        // If we need to load any strings from the server then send\n        // off the request.\n        Ajax.call(requestData, true, false);\n    }\n\n    // We need to use jQuery here because some calling code uses the\n    // .done handler instead of the .then handler.\n    return $.when.apply($, stringPromises)\n        .then((...strings) => strings)\n}\n"]}