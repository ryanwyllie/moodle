{"version":3,"sources":["../src/user_date.js"],"names":["define","$","Ajax","Storage","Config","promisesCache","getKey","request","language","attr","replace","usertimezone","timestamp","format","getFromLocalStorage","key","get","addToLocalStorage","value","set","inPromisesCache","getFromPromisesCache","addToPromisesCache","promise","loadDatesFromServer","dates","args","map","data","methodname","contextid","timestamps","call","then","results","forEach","index","date","deferred","resolve","catch","ex","reject","requests","ajaxRequests","promises","push","Deferred","cached","length","when","apply","arguments","Array"],"mappings":"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","file":"user_date.min.js","sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * Fetch and render dates from timestamps.\n *\n * @module     core/user_date\n * @package    core\n * @copyright  2017 Ryan Wyllie <ryan@moodle.com>\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\ndefine(['jquery', 'core/ajax', 'core/sessionstorage', 'core/config'],\n        function($, Ajax, Storage, Config) {\n\n    /** @var {object} promisesCache Store all promises we've seen so far. */\n    var promisesCache = {};\n\n    /**\n     * Generate a cache key for the given request. The request should\n     * have a timestamp and format key.\n     *\n     * @param {object} request\n     * @return {string}\n     */\n    var getKey = function(request) {\n        var language = $('html').attr('lang').replace(/-/g, '_');\n        return 'core_user_date/' +\n               language + '/' +\n               Config.usertimezone + '/' +\n               request.timestamp + '/' +\n               request.format;\n    };\n\n    /**\n     * Retrieve a transformed date from the browser's storage.\n     *\n     * @param {string} key\n     * @return {string}\n     */\n    var getFromLocalStorage = function(key) {\n        return Storage.get(key);\n    };\n\n    /**\n     * Save the transformed date in the browser's storage.\n     *\n     * @param {string} key\n     * @param {string} value\n     */\n    var addToLocalStorage = function(key, value) {\n        Storage.set(key, value);\n    };\n\n    /**\n     * Check if a key is in the module's cache.\n     *\n     * @param {string} key\n     * @return {bool}\n     */\n    var inPromisesCache = function(key) {\n        return (typeof promisesCache[key] !== 'undefined');\n    };\n\n    /**\n     * Retrieve a promise from the module's cache.\n     *\n     * @param {string} key\n     * @return {object} jQuery promise\n     */\n    var getFromPromisesCache = function(key) {\n        return promisesCache[key];\n    };\n\n    /**\n     * Save the given promise in the module's cache.\n     *\n     * @param {string} key\n     * @param {object} promise\n     */\n    var addToPromisesCache = function(key, promise) {\n        promisesCache[key] = promise;\n    };\n\n    /**\n     * Send a request to the server for each of the required timestamp\n     * and format combinations.\n     *\n     * Resolves the date's deferred with the values returned from the\n     * server and saves the value in local storage.\n     *\n     * @param {array} dates\n     * @return {object} jQuery promise\n     */\n    var loadDatesFromServer = function(dates) {\n        var args = dates.map(function(data) {\n            return {\n                timestamp: data.timestamp,\n                format: data.format\n            };\n        });\n\n        var request = {\n            methodname: 'core_get_user_dates',\n            args: {\n                contextid: Config.contextid,\n                timestamps: args\n            }\n        };\n\n        return Ajax.call([request], true, true)[0].then(function(results) {\n            results.dates.forEach(function(value, index) {\n                var date = dates[index];\n                var key = getKey(date);\n\n                addToLocalStorage(key, value);\n                date.deferred.resolve(value);\n            });\n            return;\n        })\n        .catch(function(ex) {\n            // If we failed to retrieve the dates then reject the date's\n            // deferred objects to make sure they don't hang.\n            dates.forEach(function(date) {\n                date.deferred.reject(ex);\n            });\n        });\n    };\n\n    /**\n     * Takes an array of request objects and returns a promise that\n     * is resolved with an array of formatted dates.\n     *\n     * The values in the returned array will be ordered the same as\n     * the request array.\n     *\n     * This function will check both the module's static promises cache\n     * and the browser's session storage to see if the user dates have\n     * already been loaded in order to avoid sending a network request\n     * if possible.\n     *\n     * Only dates not found in either cache will be sent to the server\n     * for transforming.\n     *\n     * A request object must have a timestamp key and a format key.\n     *\n     * E.g.\n     * var request = [\n     *     {\n     *         timestamp: 1293876000,\n     *         format: '%d %B %Y'\n     *     },\n     *     {\n     *         timestamp: 1293876000,\n     *         format: '%A, %d %B %Y, %I:%M %p'\n     *     }\n     * ];\n     *\n     * UserDate.get(request).done(function(dates) {\n     *     console.log(dates[0]); // prints \"1 January 2011\".\n     *     console.log(dates[1]); // prints \"Saturday, 1 January 2011, 10:00 AM\".\n     * });\n     *\n     * @param {array} requests\n     * @return {object} jQuery promise\n     */\n    var get = function(requests) {\n        var ajaxRequests = [];\n        var promises = [];\n\n        // Loop over each of the requested timestamp/format combos\n        // and add a promise to the promises array for them.\n        requests.forEach(function(request) {\n            var key = getKey(request);\n\n            // If we've already got a promise then use it.\n            if (inPromisesCache(key)) {\n                promises.push(getFromPromisesCache(key));\n            } else {\n                var deferred = $.Deferred();\n                var cached = getFromLocalStorage(key);\n\n                if (cached) {\n                    // If we were able to get the value from session storage\n                    // then we can resolve the deferred with that value. No\n                    // need to ask the server to transform it for us.\n                    deferred.resolve(cached);\n                } else {\n                    // Add this request to the list of ones we need to load\n                    // from the server. Include the deferred so that it can\n                    // be resolved when the server has responded with the\n                    // transformed values.\n                    request.deferred = deferred;\n                    ajaxRequests.push(request);\n                }\n\n                // Remember this promise for next time so that we can\n                // bail out early if it is requested again.\n                addToPromisesCache(key, deferred.promise());\n                promises.push(deferred.promise());\n            }\n        });\n\n        // If we have any requests that we couldn't resolve from the caches\n        // then let's ask the server to get them for us.\n        if (ajaxRequests.length) {\n            loadDatesFromServer(ajaxRequests);\n        }\n\n        // Wait for all of the promises to resolve. Some of them may be waiting\n        // for a response from the server.\n        return $.when.apply($, promises).then(function() {\n            // This looks complicated but it's just converting an unknown\n            // length of arguments into an array for the promise to resolve\n            // with.\n            return arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments);\n        });\n    };\n\n    return {\n        get: get\n    };\n});\n"]}